title: 关于C语言中链表的感想
url: 74.html
id: 74
categories:
  - 技术研究
tags:
  - C
  - 算法
date: 2018-12-11 23:02:54
---
今天学了一种基础的数据结构，链表。其实我学习链表的兴趣主要来自思考如何解决约瑟夫环及其相关的需要记录状态的问题的解法。 （其实约瑟夫环有一种简便的递归解法[https://blog.csdn.net/yanweibujian/article/details/50876631](https://blog.csdn.net/yanweibujian/article/details/50876631)） 链表是什么？在我的理解中，这就是一种不连续的数组。每一个元素或者部分（链表中叫结点）由指针来记录位置或者指向，用链表的好处就是可以防止用数组导致的内存空间浪费或者不足（如果使用动态链表）。下面我来说说我踩的坑。 
Typedef
---
我们在使用链表时经常会遇到这种情况： 于是这个时候我就想，后面也要用到man这个数据类型，不如用typedef 这样就再也不用写struct了。 于是写成这样 

```C
typedef struct man{… Person *next; }person;
```

然而这样子是不行的，因为typedef要编译之后才有类型person，所以不行。 解决办法是写成这样: 
```C
typedef struct man{ 
	... 
   struct man *next; 
   }person;
```
此时person 和 struct man等价。
链表需要用malloc函数
---
这里不多说了,居然需要用强制类型转换将函数返回的void *指针转换成我要的person *类型。明明谭浩强说不用。 
sizeof()原来是一个运算符而不是函数
---
sizeof()这个跟宏定义一样也是在编译之前就会把值给算出来的，我今天才知道。 

第四个坑是环形链表和单向链表，双向链表的实现。具体的可以再写一篇文章了，不多说了。 

第五，第六个坑我还没解决，不过好像暂时没什么问题。第五个坑也就是如何释放每个节点，尤其是环形链表的释放，这个东西到时候再说吧。第六个坑就是链表的节点的插入，删除，要考虑头，中间，尾各种情况，在此做个记录，下次要完全搞懂。 最终我终于实现了这个约瑟夫环问题。今天成就感还不错。