<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>18-21年读过的那些技术书</title>
      <link href="/2022/02/04/18-21%E5%B9%B4%E8%AF%BB%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E6%8A%80%E6%9C%AF%E4%B9%A6/"/>
      <url>/2022/02/04/18-21%E5%B9%B4%E8%AF%BB%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E6%8A%80%E6%9C%AF%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>这篇博客总结了我在 2018-2021 年读过的技术书籍。我会在每本书的具体描述里说明自己读这本书的详尽程度<code>（粗读/部分细读/整体细读/多次品味）</code>，我对这本书的总体评价<code>（值得一读/给人启发/偶有精华/厕纸）</code>。</p><p>无论书的好坏，只要我有读过一部分，我都会在文章里面提及，因为我希望我踩过的坑后人不要再踩了。</p><h1 id="最□□的那些书"><a href="#最□□的那些书" class="headerlink" title="最□□的那些书"></a>最□□的那些书</h1><p>这一部分的书是我心目中最重要的一些计算机书籍。我没资格给这一部分书总体评价，大家看着乐乐就好。</p><h2 id="最厚最长的书"><a href="#最厚最长的书" class="headerlink" title="最厚最长的书"></a>最厚最长的书</h2><p>《<a href="https://book.douban.com/subject/26681685/">计算机程序设计艺术</a>》（The Art Of Computer Programming 简称 TAOCP），是由计算机科学巨匠 Donald Ervin Knuth 所著的一系列书籍，描述了计算机科学不同方面的知识。</p><p>我精读了这系列书大约0.1%的部分。我精读过的两个部分如下：第一卷MMIX描述了二叉树遍历的部分和第二卷半数值算法的为了讲解随机数生成部分。我是先读的第二卷，当时我以为这本书对数学算法的讲解还挺有意思的。但直到我看到了第一卷书之后我就知道我永远不可能用这套书学会编程和算法了： Knuth 在这本书里自创了一套汇编语言MMIX，并用这门语言描述书中的算法。</p><p>Knuth 其人非常厉害，他和人合作发明了 KMP 算法，也写出了 Tex，METAFONT 两个软件，提出了文学编程的概念（我觉得启发了Jupyter Notebook？）。但人厉害与书好看不完全相关，如果你不希望斥巨资买了一套用来膜拜巨佬的巨书，建议还是先在图书馆翻翻这套书你能否看得下去。最后，我个人认为 Knuth 的《具体数学》比这套书更具可读性。</p><blockquote><p>如果你完完整整读完了TAOCP，请立刻给我发一份简历。——比尔盖茨</p></blockquote><p>总体评价：不适合智商低于比尔盖茨的人看。</p><h2 id="最给人启发的书"><a href="#最给人启发的书" class="headerlink" title="最给人启发的书"></a>最给人启发的书</h2><blockquote><p>计算机科学并不只是关于计算机，就像天文学并不只是关于望远镜一样。</p></blockquote><p>《<a href="https://book.douban.com/subject/1148282/">计算机程序的构造与解释</a>》（Structure and Interpretation of Computer Programs 简称 SICP。注意，译者是裘宗燕！！）应该配合着 MIT 的 SICP 课一起看。然后你可以在短短的几天内了解到这些问题的答案：什么是类 Lisp 的语言Scheme？什么是抽象？什么是自上而下编程？什么是函数式编程？什么是面向对象？什么是面向过程？并行编程中会出现什么样的问题？什么是解释器？什么是垃圾回收？什么是编译器？</p><p>读了这本书，做了其中1-2章相关的课后习题就会明白 Lisp 语言和函数式编程的精髓，再做第3章习题你就明白了Alan Kay说的“面向对象就是消息传递”。但是后面几章我只看了课没有做习题，只有一些粗略的印象了，例如如何用 Scheme 写一个 Scheme Parser 这种。</p><p>如果你在我看这本书之前跟我聊函数式编程，我绝对不知所以然，并可能会被什么“闭包”之类的术语骗的团团转。但是我在看了这本书之后，我暗自为不了解函数式编程“函数作为一等公民”这一思想的人惋惜，因为他们不知道自己没接触到多么大的一个世界。</p><p>这本书首次出版是在 1984 年，但在 2022 年这本书第一次更换了书中使用的编程语言：从 Scheme 更换到了JavaScript。我认为这个更换是有道理的，因为 JavaScript 设计的时候就参考了 Scheme 的函数作为第一公民的设计，并且我在亲身使用的时候确实感受到 ES6 之后的 JavaScript 有着类 Scheme 的使用体验。期待 2022 版 SICP 能够重现旧版的荣光。</p><p>总体评价：无论是什么语言版本的 SICP，都不可不读。</p><h2 id="最实用的大书"><a href="#最实用的大书" class="headerlink" title="最实用的大书"></a>最实用的大书</h2><p>《代码大全》（Code Complete。注意，裘宗燕强力审校！！）由微软的一位程序员编写。我一开始以为这本书是一本算法大全，翻了才知道原来从编码到管理无所不包。这本书的英文名意思是编码完成，但是由于第一版已经被某人翻译成了代码大全，于是积重难返第二版还是叫做了代码大全。具体你需不需要读这本书，请你来看看这本书中文版的译序，摘抄如下：</p><blockquote><p>这本书适合谁看，该怎么看?<br>任何想写出好程序的人，或者想带领一群程序员写出好软件的人，都不应该错过这本好书。作者在前言中指明了本书的读者群（包括经验丰富的程序员、技术带头人、自学的程序员、学生等），请您参阅。<br>这是一本 800 多页的大部头，从头到尾阅读要花不少时间，谁都希望能尽快找到对自己有用的内容。译者大致针对不同的读者群提一点阅读建议，仅供参考。</p></blockquote><blockquote><p>• 初级程序员，请先看第18章 “表驱动法”：将复杂的逻辑判断转换为查表，从而简化代码的编写与维护。另外，本章中的一个示例说明了，面向对象设计并不只要因为它是“面向对象”，就一定会好于其他的设计。<br>• 高级程序员，请先看第4章“关键的‘构建，决策”，本章关注的焦点是程序员和技术带头人个人必须（直接或间接）负责的项目准备工作。<br>• 高级程序员，请先看第4章“关键的‘构建，决策”，本章关注的焦点是程序员和技术带头人个人必须（直接或间接）负责的项目准备工作。<br>• 项目经理，请先看第33章“个人性格”，程序设计是一项纯粹的脑力劳动，本章对挑选和培养优秀程序员提出了建议。事实证明，相对于聪明程度（智商），个人性格（情商）对于造就出程序员高手更具有决定性的意义。<br>• 低年级学生，请先看第 11 章“变量名的力量”。这本书用了整整一章（30多页）的篇幅来讲解“为变量命名”这一编程中最常见的活动，这里提供的建议在别的书里是很难见到的。<br>• 高年级学生，请先看第8章“防御式编程”，本章讲述如何面对严酷的充斥非法数据的真实世界，在遇到“绝不会发生”的事件和其他程序员犯下的错误时如何保护自己。对于那些正在从学术环境转向专业开发环境的学生来说，这是必备的一课。<br>• 制定编码标准的人，请先看第32章“自说明代码”，本章中有一段关于注释的精彩对话，它可能会改变您在制定编码标准时对注释的要求。<br>• 自学编程的人，请先看第7章 “高质量的子程序”，本章详细讨论了子程序的命名和參数选择等问题，其中对子程序最佳长度的讨论颇有借鉴意义。<br>• 喜欢参与网上争论的人，请先看第13.3节“全局数据〞 和第17.3节“goto 语句”，听听学术界在这些问题上的争论也挺有意思。</p></blockquote><blockquote><p>当然，这整本书都非常值得一读，准确地说，值得反复阅读。书中不仅有实实在在的数据和论述，也有一些有趣的比喻，作者偶尔还开开玩笑，读起来一点也不枯燥，</p></blockquote><p>总体评价：如果你对以上话题感兴趣，推荐你读一下这本书看看作者观点吧。如果你没有感兴趣的话题，你真的想从事计算机相关工作吗！？</p><h2 id="最优雅的软件开发书"><a href="#最优雅的软件开发书" class="headerlink" title="最优雅的软件开发书"></a>最优雅的软件开发书</h2><p>《实现模式》（Implementation Patterns）是由敏捷开发的发起人之一 Kent Beck 所著的一本小书。Kent Beck 提出了测试驱动开发，并且发明了 JUnit 测试框架。</p><p>在这本书里，Kent Beck 手把手教你写代码。里面的每个实现模式都是你可能想问的问题：什么是双重/多重分派？我应该在创建对象的时候初始化一个属性还是在第一次访问的时候初始化？这本书深入浅出的风格非常适合读者理解其中的思想。</p><p>这本书我反复读了 3 遍。我在看完这本书之后才第一次理解了设计模式里面的 Visitor 模式，而且想出来了Visitor模式的出现是因为语言拿不到类型导致要绕两下才能执行真正逻辑。如果你在设计 Java 类的时候觉得某一步的选择太多，不如来看看这本书里的例子找找灵感。</p><p>总结：被很多人轻视的好书。</p><h2 id="最应该早点读的书"><a href="#最应该早点读的书" class="headerlink" title="最应该早点读的书"></a>最应该早点读的书</h2><p>《<a href="https://book.douban.com/subject/1148282/">深入理解计算机系统</a>》（Computer Systems: A Programmer’s Perspective 简称 CSAPP）这本书是 CMU 的计算机导论课课本，也是哈工大等学校的计算机导论课的计算机课本。也就是说，很多学校的计算机导论课也应该覆盖这本书里讲的很多内容：数据与程序的二进制表示，机器语言，机器指令集，程序的缓存相关性，操作系统、并发和网络编程。这本书对于计算机相关专业的学生而言越早读越好，因为可以更早的拥有对整个计算机系统的大局观。</p><p>这本书我详细阅读了其中的几个部分，记忆中机器指令集那个部分我跳过了。总体而言，因为这本书深入浅出的写作风格、有意思的课后 Lab 和网上详尽的相关资料，使这本书成为了我心目中计算机导论相关书籍的 No.1。</p><p>总体评价：越早读越好。</p><h1 id="数据库相关书籍"><a href="#数据库相关书籍" class="headerlink" title="数据库相关书籍"></a>数据库相关书籍</h1><h2 id="数据库系统概论"><a href="#数据库系统概论" class="headerlink" title="数据库系统概论"></a>数据库系统概论</h2><p>《<a href="https://book.douban.com/subject/26317662/">数据库系统概论</a>》这本书是我们的数据库课程的课本。我很感谢这本书为我启蒙了许多概念例如先写日志，还有事务隔离性、也教会了我 SQL 的基本使用。在我大学四年用的课本里面，这本课本是优秀程度仅次于《<a href="https://book.douban.com/subject/26960678/">计算机网络</a>》的课本。</p><p>我的阅读程度：部分精读。<br>我的推荐程度：给人启发</p><h2 id="MySQL必知必会"><a href="#MySQL必知必会" class="headerlink" title="MySQL必知必会"></a>MySQL必知必会</h2><p>《<a href="https://book.douban.com/subject/35167240/">MySQL必知必会</a>》。很小的一本工具书，学 SQL 用的。我觉得学 SQL 看这本书没啥问题。</p><p>我的阅读程度：整体粗读。<br>我的推荐程度：偶有精华。</p><h2 id="你不可不知的关系数据库理论"><a href="#你不可不知的关系数据库理论" class="headerlink" title="你不可不知的关系数据库理论"></a>你不可不知的关系数据库理论</h2><p>《<a href="https://book.douban.com/subject/26340956/">你不可不知的关系数据库理论</a>》讲的主要是关系型数据库中的精华概念。很多书讲关系型数据库上来就要先谈 SQL ，这本书就是在教你没有 SQL 怎么理解表之间的交、并、笛卡尔积、除、连接。这本书篇幅很小，如在没接触过关系型数据库的情况下看这本书可以快速入门。</p><p>我的阅读程度：部分精读。<br>我的推荐程度：偶有精华。</p><h2 id="七周七数据库"><a href="#七周七数据库" class="headerlink" title="七周七数据库"></a>七周七数据库</h2><p>《<a href="https://book.douban.com/subject/24737847/">七周七数据库</a>》是一本谈了多种数据库范式的书。7个数据库依次是：postgresql、riak、apache hbase、mongodb、apache couchdb、neo4j和redis。如果你对于 NoSQL、NewSQL、列式数据库、图数据库等概念感兴趣却又一无所知，可以通过阅读此书来快速获得大局观。</p><p>我的阅读程度：部分精读。<br>我的推荐程度：给人启发。</p><h2 id="数据库系统概念"><a href="#数据库系统概念" class="headerlink" title="数据库系统概念"></a>数据库系统概念</h2><p>《<a href="https://book.douban.com/subject/10548379/">数据库系统概念</a>》此书我直截了当的承认自己展示还没怎么读。此书太厚，我当时读的时候也是为了具体了解1NF，2NF，BNF，3NF等范式，这本书上的解释对我而言还算是能够看懂。这本书豆瓣评分很高，但是实在太厚太长了。</p><p>我的阅读程度：部分粗读。<br>我的推荐程度：我没怎么看，没法客观评价。</p><h2 id="Redis-设计与实现"><a href="#Redis-设计与实现" class="headerlink" title="Redis 设计与实现"></a>Redis 设计与实现</h2><p>《<a href="https://book.douban.com/subject/25900156/">Redis 设计与实现</a>》这本书我当时是好奇 Redis 中的跳表数据结构去看的，但是但是我才大一上，C语言都用不利索，看这个书属于自讨苦吃。但是我能确定的是这本书里图很多，而且有仔细的讲 Redis 里面的数据结构，文笔也还可以。</p><p>我的阅读程度：部分粗读。<br>我的推荐程度：我没怎么看，没法客观评价。</p><h1 id="C-相关书籍"><a href="#C-相关书籍" class="headerlink" title="C++ 相关书籍"></a>C++ 相关书籍</h1><p>C++ 是我认真学习的第一门面向对象语言。这门语言在所有领域的雄心壮志和其曾经的语言基础设施严重不符，这导致这门语言涌现出了无数 Effective 系列，无数最佳实践书籍，以及 RAII, move sementic, SFINAE, CRTP,等等让人自我感觉良好的黑话术语。在后 C++11 时代，比老书有用的是多 CPPCON 上的演讲，和 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference</a>。</p><h2 id="Essential-C-中文版"><a href="#Essential-C-中文版" class="headerlink" title="Essential C++ 中文版"></a>Essential C++ 中文版</h2><p>《<a href="https://book.douban.com/subject/24868427/">Essential C++ 中文版</a>》这本书面向的读者是只会 C 语言的人，目的是让读者快速感受到 C++ 面向对象的封装、继承和多态是怎么体现的。我仔细地读过此书 3 遍，是通过此书入门 C++ 的，我将此书推荐给所有人。这本书的精神续作是 C++ 之父写的《<a href="https://book.douban.com/subject/34809273/">A Tour of C++</a>》,在后 C++11的今天我推荐大家先看 <a href="https://book.douban.com/subject/34809273/">A Tour of C++</a>.</p><p>阅读程度：多次品味。<br>推荐程度：值得一读。</p><h2 id="Effective-STL-中文版-50条有效使用STL的经验"><a href="#Effective-STL-中文版-50条有效使用STL的经验" class="headerlink" title="Effective STL 中文版 :50条有效使用STL的经验"></a>Effective STL 中文版 :50条有效使用STL的经验</h2><p>《<a href="https://book.douban.com/subject/1792179/">Effective STL中文版</a>》这书里全是怎么用 C++98 的 STL 的相关经验，经过我的观察，其中至少还有一半以上还在 C++11 以上适用，例如不要用<code>std::vector&lt;bool&gt;</code>等，但也有许多不适用的。我认为 STL 的数据结构库的学习直接打好数据结构基础然后看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference</a>即可，而学 STL 的算法部分推荐大家先看<a href="https://www.bilibili.com/video/BV1Ub411H7A3">一小时内学会105个STL算法</a>。</p><p>阅读程度：多次品味。<br>推荐程度：值得一读。</p><h2 id="Effective-C-改善程序与设计的55个具体做法-Effective-Modern-C-中文版"><a href="#Effective-C-改善程序与设计的55个具体做法-Effective-Modern-C-中文版" class="headerlink" title="Effective C++:改善程序与设计的55个具体做法 / Effective Modern C++ :中文版"></a>Effective C++:改善程序与设计的55个具体做法 / Effective Modern C++ :中文版</h2><p><a href="https://book.douban.com/subject/5387403/">前书</a>写于 C++98 时代，<a href="https://book.douban.com/subject/30178902/">后书</a>写于 C++14 时代，两本书之间没有多少冲突，可以互相补充阅读。看前书你会了解到很多最佳实践，但如果你要在现在写库，你必须看后书了解什么 TMD 是 TMD <code>decltype(auto)</code> 还有 TMD 右值引用，<code>std::move</code> 和完美转发。说实话，我觉得 C++ 写到这个份上已经没什么意思了，很难受（两本书的作者 Scott Meyers 选择了<a href="http://scottmeyers.blogspot.com/2015/12/good-to-go.html">退出 C++ 世界</a>）。<br>最后，给大家一句话讲明白右值引用吧：右值引用是用来实现移动语义（即资源所有权的转移）而加入 C++ 的类型。</p><p>阅读程度：多次品味。<br>推荐程度：值得一读。</p><h2 id="C-编程规范-101-条规则、准则与最佳实践-101-Rules-Guidelines-and-Best-Practices"><a href="#C-编程规范-101-条规则、准则与最佳实践-101-Rules-Guidelines-and-Best-Practices" class="headerlink" title="C++编程规范 :101 条规则、准则与最佳实践 :101 Rules, Guidelines, and Best Practices"></a>C++编程规范 :101 条规则、准则与最佳实践 :101 Rules, Guidelines, and Best Practices</h2><p>《<a href="https://book.douban.com/subject/1480481/">C++编程规范</a>》是 C++98 时代的书籍，但其中的很多东西现在依然是对的，例如优先 const，优先使用组合，少用宏等等等等，这本书能帮助你写出品味良好的 C++ 代码，推荐大家值得一读。</p><p>阅读程度：多次品味。<br>推荐程度：值得一读。</p><h2 id="C-程序设计语言-C-语言的设计和演化"><a href="#C-程序设计语言-C-语言的设计和演化" class="headerlink" title="C++ 程序设计语言/ C++ 语言的设计和演化"></a>C++ 程序设计语言/ C++ 语言的设计和演化</h2><p>两本书都是由 C++ 之父 Bjarne Stroustrup 所著，裘宗燕译！</p><p>《<a href="https://book.douban.com/subject/4604591/">C++程序设计语言</a>》此书的第一版由裘宗燕所译，这本书里面很多用词什么的和一般书籍不像，例如 Interface 被翻译成界面（一般译为接口），但这丝毫不影响信息传达的效率。假如你对某些 C++ 语言中的语法有疑惑，这本书可以给出最详尽且带例子的讲解。这本书的最大问题就是厚的要命，尤其是最新版，厚的分出一本书专门讲标准库。</p><p>《<a href="https://book.douban.com/subject/1096216/">C++语言的设计和演化</a>》这本书说明了 C++98 设计过程中的取舍，对于 C++ 中很多设计有疑惑的可以看一下这本书，例如为什么异常是 try catch 而不是其他方式，以及为什么有多继承等等。当然，如果想看新的 C++ 语言特性为何是那样，可以看 C++ 之父在 CPPCON 上的演讲以及他投稿到 HOPL 上的讲述 C++ 历史的论文。</p><p>阅读程度：部分精读。<br>推荐程度：值得一读。</p><h2 id="C-Primer"><a href="#C-Primer" class="headerlink" title="C++ Primer"></a>C++ Primer</h2><p>《<a href="https://book.douban.com/subject/25708312/">C++ Primer</a>》这本书适合每一个正在学习 C++ 的人阅读。作为一本教学用书，文字详略得当，描述深入浅出。在深度广度两个方面同时做的非常好，我认为适合作为所有人学习 C++ 的第二本书。</p><p>阅读程度：部分精读。<br>推荐程度：值得一读。</p><h2 id="C-Primer-Plus"><a href="#C-Primer-Plus" class="headerlink" title="C++ Primer Plus"></a>C++ Primer Plus</h2><p>如果说上一本 C++ Primer 是李逵，那么这一本《<a href="https://book.douban.com/subject/26792521/">C++ Primer Plus</a>》就是李鬼。书又厚又长，目标读者是完全的初学者，但是内容详略严重不当，读起来枯燥无味。我觉得只能当写的不太好的语法手册用，因此我很后悔购买此书。</p><p>阅读程度：部分精读。<br>推荐程度：厕纸。</p><h1 id="待更新中"><a href="#待更新中" class="headerlink" title="待更新中"></a>待更新中</h1><h1 id="Java-相关书籍"><a href="#Java-相关书籍" class="headerlink" title="Java 相关书籍"></a>Java 相关书籍</h1><h2 id="写给大忙人看的Java核心技术"><a href="#写给大忙人看的Java核心技术" class="headerlink" title="写给大忙人看的Java核心技术"></a>写给大忙人看的Java核心技术</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="有趣的二进制"><a href="#有趣的二进制" class="headerlink" title="有趣的二进制"></a>有趣的二进制</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h1 id="Python-相关书籍"><a href="#Python-相关书籍" class="headerlink" title="Python 相关书籍"></a>Python 相关书籍</h1><h2 id="流畅的Python"><a href="#流畅的Python" class="headerlink" title="流畅的Python"></a>流畅的Python</h2><h2 id="Python-3-Cookbook"><a href="#Python-3-Cookbook" class="headerlink" title="Python 3 Cookbook"></a>Python 3 Cookbook</h2><h2 id="Python自然语言处理"><a href="#Python自然语言处理" class="headerlink" title="Python自然语言处理"></a>Python自然语言处理</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="自然语言处理综论"><a href="#自然语言处理综论" class="headerlink" title="自然语言处理综论"></a>自然语言处理综论</h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="Erlang趣学指南"><a href="#Erlang趣学指南" class="headerlink" title="Erlang趣学指南"></a>Erlang趣学指南</h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h2 id="数据结构邓俊辉"><a href="#数据结构邓俊辉" class="headerlink" title="数据结构邓俊辉"></a>数据结构邓俊辉</h2><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><h2 id="数据结构与算法分析-C-语言描述"><a href="#数据结构与算法分析-C-语言描述" class="headerlink" title="数据结构与算法分析 :C++语言描述"></a>数据结构与算法分析 :C++语言描述</h2><h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><h2 id="递归与函数式的奥妙"><a href="#递归与函数式的奥妙" class="headerlink" title="递归与函数式的奥妙"></a>递归与函数式的奥妙</h2><h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><h2 id="ACM-ICPC算法基础训练教程"><a href="#ACM-ICPC算法基础训练教程" class="headerlink" title="ACM/ICPC算法基础训练教程"></a>ACM/ICPC算法基础训练教程</h2><p>《<a href=""></a>》</p><h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><h2 id="七周七语言言-理解多种编程范型-a-pragmatic-guide-to-learning-programming-language"><a href="#七周七语言言-理解多种编程范型-a-pragmatic-guide-to-learning-programming-language" class="headerlink" title="七周七语言言 :理解多种编程范型 :a pragmatic guide to learning programming language"></a>七周七语言言 :理解多种编程范型 :a pragmatic guide to learning programming language</h2><h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><h2 id="点石成金-访客至上的Web和移动可用性设计秘笈"><a href="#点石成金-访客至上的Web和移动可用性设计秘笈" class="headerlink" title="点石成金 :访客至上的Web和移动可用性设计秘笈"></a>点石成金 :访客至上的Web和移动可用性设计秘笈</h2><h2 id="-10"><a href="#-10" class="headerlink" title=""></a></h2><h2 id="C程序设计新思维"><a href="#C程序设计新思维" class="headerlink" title="C程序设计新思维"></a>C程序设计新思维</h2><h2 id="-11"><a href="#-11" class="headerlink" title=""></a></h2><h2 id="Git高手之路"><a href="#Git高手之路" class="headerlink" title="Git高手之路"></a>Git高手之路</h2><h2 id="-12"><a href="#-12" class="headerlink" title=""></a></h2><h2 id="-13"><a href="#-13" class="headerlink" title=""></a></h2><h2 id="程序员的数学"><a href="#程序员的数学" class="headerlink" title="程序员的数学"></a>程序员的数学</h2><h2 id="-14"><a href="#-14" class="headerlink" title=""></a></h2><h2 id="Qt-5开发及实例-含典型案例视频分析"><a href="#Qt-5开发及实例-含典型案例视频分析" class="headerlink" title="Qt 5开发及实例 :含典型案例视频分析"></a>Qt 5开发及实例 :含典型案例视频分析</h2><h2 id="-15"><a href="#-15" class="headerlink" title=""></a></h2><h2 id="More-Exceptional-C-中文版-40个新的工程难题、编程疑问及解决方法-40-new-enginee-5开发及实例-含典型案例视频分析"><a href="#More-Exceptional-C-中文版-40个新的工程难题、编程疑问及解决方法-40-new-enginee-5开发及实例-含典型案例视频分析" class="headerlink" title="More Exceptional C++中文版 :40个新的工程难题、编程疑问及解决方法 :40 new enginee 5开发及实例 :含典型案例视频分析"></a>More Exceptional C++中文版 :40个新的工程难题、编程疑问及解决方法 :40 new enginee 5开发及实例 :含典型案例视频分析</h2><h2 id="-16"><a href="#-16" class="headerlink" title=""></a></h2><h2 id="Qt编程快速入门"><a href="#Qt编程快速入门" class="headerlink" title="Qt编程快速入门"></a>Qt编程快速入门</h2><h2 id="-17"><a href="#-17" class="headerlink" title=""></a></h2><h2 id="程序员的数学-1"><a href="#程序员的数学-1" class="headerlink" title="程序员的数学"></a>程序员的数学</h2><h2 id="-18"><a href="#-18" class="headerlink" title=""></a></h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="-19"><a href="#-19" class="headerlink" title=""></a></h2><h2 id="-20"><a href="#-20" class="headerlink" title=""></a></h2><h2 id="轻量级Django"><a href="#轻量级Django" class="headerlink" title="轻量级Django"></a>轻量级Django</h2><h2 id="-21"><a href="#-21" class="headerlink" title=""></a></h2><h2 id="Python-UNIX和Linux系统管理指南"><a href="#Python-UNIX和Linux系统管理指南" class="headerlink" title="Python UNIX和Linux系统管理指南"></a>Python UNIX和Linux系统管理指南</h2><h2 id="-22"><a href="#-22" class="headerlink" title=""></a></h2><h2 id="Python网络数据采集"><a href="#Python网络数据采集" class="headerlink" title="Python网络数据采集"></a>Python网络数据采集</h2><h2 id="-23"><a href="#-23" class="headerlink" title=""></a></h2><h2 id="Flask-基于Python的Web应用开发实战-developing-web-applications-with-python"><a href="#Flask-基于Python的Web应用开发实战-developing-web-applications-with-python" class="headerlink" title="Flask :基于Python的Web应用开发实战 :developing web applications with python"></a>Flask :基于Python的Web应用开发实战 :developing web applications with python</h2><h2 id="-24"><a href="#-24" class="headerlink" title=""></a></h2><h2 id="交互式计算机图形学"><a href="#交互式计算机图形学" class="headerlink" title="交互式计算机图形学"></a>交互式计算机图形学</h2><h2 id="-25"><a href="#-25" class="headerlink" title=""></a></h2><h2 id="实现模式"><a href="#实现模式" class="headerlink" title="实现模式"></a>实现模式</h2><h2 id="-26"><a href="#-26" class="headerlink" title=""></a></h2><h2 id="代码之外的功夫-程序员精进之路-be-more-than-just-a-code-monkey"><a href="#代码之外的功夫-程序员精进之路-be-more-than-just-a-code-monkey" class="headerlink" title="代码之外的功夫 :程序员精进之路 :be more than just a code monkey"></a>代码之外的功夫 :程序员精进之路 :be more than just a code monkey</h2><h2 id="-27"><a href="#-27" class="headerlink" title=""></a></h2><h2 id="-28"><a href="#-28" class="headerlink" title=""></a></h2><h2 id="-29"><a href="#-29" class="headerlink" title=""></a></h2><h2 id="ACM国际大学生程序设计竞赛亚洲区预选赛真题题解"><a href="#ACM国际大学生程序设计竞赛亚洲区预选赛真题题解" class="headerlink" title="ACM国际大学生程序设计竞赛亚洲区预选赛真题题解"></a>ACM国际大学生程序设计竞赛亚洲区预选赛真题题解</h2><h2 id="-30"><a href="#-30" class="headerlink" title=""></a></h2><h2 id="中文版Effective"><a href="#中文版Effective" class="headerlink" title="中文版Effective"></a>中文版Effective</h2><h2 id="-31"><a href="#-31" class="headerlink" title=""></a></h2><h2 id="-32"><a href="#-32" class="headerlink" title=""></a></h2><h2 id="递归与函数式的奥妙-1"><a href="#递归与函数式的奥妙-1" class="headerlink" title="递归与函数式的奥妙"></a>递归与函数式的奥妙</h2><h2 id="-33"><a href="#-33" class="headerlink" title=""></a></h2><h2 id="Node-js实战"><a href="#Node-js实战" class="headerlink" title="Node.js实战"></a>Node.js实战</h2><h2 id="-34"><a href="#-34" class="headerlink" title=""></a></h2><h2 id="七周七语言"><a href="#七周七语言" class="headerlink" title="七周七语言"></a>七周七语言</h2><h2 id="-35"><a href="#-35" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫系列（1）：横纵向爬取、Scrapy 和 Zyte</title>
      <link href="/2021/12/29/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A8%AA%E7%BA%B5%E5%90%91%E7%88%AC%E5%8F%96%E3%80%81Scrapy%E5%92%8CZyte/"/>
      <url>/2021/12/29/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9A%E6%A8%AA%E7%BA%B5%E5%90%91%E7%88%AC%E5%8F%96%E3%80%81Scrapy%E5%92%8CZyte/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍横纵向爬取"><a href="#介绍横纵向爬取" class="headerlink" title="介绍横纵向爬取"></a>介绍横纵向爬取</h1><p>横纵向爬取用一句话就能说明白：<br>例如去房地产网站爬房子，在目录页按页爬下房子详情页链接的过程是横向爬取，更进一层爬详情页中的信息如房价地段等的过程是纵向爬取。</p><h1 id="介绍-Scrapy-爬虫框架"><a href="#介绍-Scrapy-爬虫框架" class="headerlink" title="介绍 Scrapy 爬虫框架"></a>介绍 Scrapy 爬虫框架</h1><h2 id="Scrapy-爬虫框架怎么解决横纵向爬取"><a href="#Scrapy-爬虫框架怎么解决横纵向爬取" class="headerlink" title="Scrapy 爬虫框架怎么解决横纵向爬取"></a>Scrapy 爬虫框架怎么解决横纵向爬取</h2><p>以下是 Scrapy 首页第一个例子，一个博客爬虫：<br><img src="../../../../images/pasted-4.png" alt="Scrapy 首页第一个例子的截图"><br>序号1的部分代码，Spider 返回 dict 表示纵向爬取到底获取到最终信息了。</p><p>序号2的部分代码，Spider 调用一个特殊函数，表示还要继续横向爬取。</p><p>结合 Scrapy 爬虫框架底层引擎架构。我们来理解下 Scrapy。<br><img src="../../../../images/pasted-3.png" alt="Scrapy 框架架构"></p><p>还是爬房地产网站的例子。在房地产网站目录页爬到上图第4步时 Spider 就会把详情页链接继续往 Scheduler 去放，让 Scheduler 这个 consumer 饱和工作。而在详情页就会把最终结果往 Item Pipeline 去放</p><h2 id="Scrapy-爬虫框架解决了什么问题"><a href="#Scrapy-爬虫框架解决了什么问题" class="headerlink" title="Scrapy 爬虫框架解决了什么问题"></a>Scrapy 爬虫框架解决了什么问题</h2><p>我认为最重要的是以下三点：</p><ol><li>不用结合自己找各种解析器和选择器了。HTML、XML，JSON解析，CSS选择器等等一应俱全，</li><li>可以方便的调节爬取速率，Spider 表现等。</li><li>提供了一套 CLI 工具用于监控，调试。</li></ol><p>当然，没解决的问题也有：反爬，IP限制…</p><h1 id="介绍-Zyte：爬虫-as-a-Service"><a href="#介绍-Zyte：爬虫-as-a-Service" class="headerlink" title="介绍 Zyte：爬虫 as a Service"></a>介绍 Zyte：爬虫 as a Service</h1><p>Zyte 的前身叫做 ScrapingHub，这家公司维护了 Scrapy 这个爬虫框架。于是我们可以看到 Scrapy 中许多特性与 Zyte 有关: 一键部署爬虫到 Zyte，Zyte 上可以监控爬虫、定时爬取……</p><p>当然，仅仅只提供部署服务的话，这家公司可能完全没有竞争力。作为一个 SaaS平台，他们有两个另外的服务，让我愿称它的 SaaS 为 Spider as a Service。这个服务就是，自动代理和自动结构化提取网站内容。</p><p>第一个功能叫做自动代理。不多赘述，其实就是一个给你的爬虫用的 ip 池，这个服务的杀手级还不够强。</p><p>自动结构化提取网站内容是一个杀手级功能，这个功能以 API 形式提供：</p><p>下图是典型的豆瓣小组目录页和小组。<br><img src="../../../../images/pasted-6.png" alt="upload successful"><br><img src="../../../../images/pasted-5.png" alt="upload successful"></p><p>如果你用我之前提到的方法开始横纵向爬取，然后你就会遇到频次限制，IP 限制，未登录限制，验证码限制…</p><p>但如果你使用 Zyte 的服务，只要你先调用 Article List Extraction API 横向爬取每个目录页，再批量对文章链接调用 Article List API 信息， Zyte 就能提取出来并自动识别文章页面上的每项信息如作者，发文时间，正文内容，评论作者/内容…，最后转换成json，格式类似如下：</p><pre><code class="json">&#123;    &quot;topic&quot;: &#123;        &quot;articleBody&quot;: &quot;我上上赛季低星王者，胜率大概57% 左右\n\n中野射上单都玩 就是不太会玩辅助\n\n上个赛季恶心死我了，我记得打了快两百场胜率48%这样，靠积分苟上星耀...&quot;,        &quot;headline&quot;: &quot;只要忍住一个月以上不玩，排位就会很容易！&quot;,        &quot;inLanguage&quot;: &quot;zh&quot;,        &quot;datePublished&quot;: &quot;2021-04-21T21:50:29&quot;,        &quot;datePublishedRaw&quot;: &quot;2021-04-21 21:50:29&quot;,        &quot;author&quot;: &quot;karen酱&quot;,        &quot;authorsList&quot;: [&quot;karen酱&quot;],        &quot;mainImage&quot;: &quot;https://img9.doubanio.com/icon/u181208014-2.jpg&quot;,        &quot;description&quot;: &quot;上个赛季恶心死我了，我记得打了快两百场胜率48%这样，靠积分苟上星耀，当时都要被这个游戏气哭了，下班后熬夜打也输，玩啥位置都输，擅长的英雄也输！ ！ ！&quot;,        &quot;url&quot;: &quot;https://www.douban.com/group/topic/222195435/&quot;,    &#125;,    &quot;author&quot;: &#123;        &quot;text&quot;: &quot;...&quot;,        &quot;href&quot;: &quot;...&quot;    &#125;&#125;</code></pre><p>我第一次用完这个功能之后，看着返回给我的整齐的 JSON，想起之前处理反爬的窘况，我突然感觉手写爬虫这件事变得无比的笨。毕竟，反爬这件事是不可避免的，就算你经验怎么丰富，也写不出反爬框架节约自己的时间。</p><p>那么这项服务的价格是多少呢？这项功能以 API 形式提供，在我写这篇文章时，服务的 API 调用价格是 $60/10万 次请求。充值之后只需要下载一个 SDK，你就不用处理任何反爬或者是IP池的恶心事，如果是经得住爬的网站，那么结果返回的速度飞快，约等于花钱买爬虫结果+节约的时间。</p><h1 id="总结和声明"><a href="#总结和声明" class="headerlink" title="总结和声明"></a>总结和声明</h1><p>最后声明，本文不是 Zyte 的软文。因为 Zyte 在本文写作时还没有任何邀请优惠计划，并且我也没放什么邀请链接之类的。那么我是怎么试用到这个公司的产品呢？因为 Github 学生包提供了10万个请求，于是我就试了一下，发现确实好用。所以说这也给我了一个商业上的启发，就是在学生时期培养消费习惯确实是有效的。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>这篇应该是完结篇了。我认为爬虫在中国的法律风险实在太大，我在上篇文章最开头就描述了自己根本不想爬虫的心情。但是我认为这些经验级知识落到笔下还是有好处的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫系列（0）：工作流与总览</title>
      <link href="/2021/05/20/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%EF%BC%880%EF%BC%89%EF%BC%9A%E6%80%BB%E8%A7%88%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
      <url>/2021/05/20/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%EF%BC%880%EF%BC%89%EF%BC%9A%E6%80%BB%E8%A7%88%E4%B8%8E%E7%BB%8F%E5%85%B8%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="太长不读"><a href="#太长不读" class="headerlink" title="太长不读"></a>太长不读</h1><ol><li>能不爬，就不爬。最省力的方法是不爬，然后才是用工具爬。</li><li>爬取要讲道德：遵守 robots.txt, 频率不能太高，不能爬法律不允许的东西，把网站爬挂了，或是法律上出了问题，可能还是程序员背锅。公开 API 如需要授权，先去试着联系下合作。</li></ol><blockquote><p>豆瓣的图书评分，是国内图书评价体系最好的。几家电商网站，自己也做图书评价体系，做得乱七八糟，尤其是京东，为什么不直接和豆瓣合作一下呢？调用豆瓣 API 就行了啊。但中国互联网公司之间，是没有 API 的，中国互联网行业通行的 API 其实是爬虫。<br>– <a href="https://new.qq.com/omn/20200503/20200503A0CU8V00.html">豆瓣是中国互联网的骄傲</a></p></blockquote><blockquote><p>第一次和阿北认识是在十几年前的上海，当时和Mtime的马锐拉三个人约在徐家汇的一个星巴克里，商量如何把豆瓣、VeryCD、Mtime的电影资料用开放协议打通。<br>那是Web2.0的黄金年代，大家都认为开放是理所应当的，各网站各司其职拼凑起一个更丰富的互联网。无需登录注册的API、RSS、XML导出都是当年的标配。<br>– <a href="https://twitter.com/DashHuang/status/1468043778128711682">@DashHuang</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>出于兴趣或各种目的，我在网上抓取过各种不同的数据，还做过一个半成品级别的增量爬虫框架。这个文章系列里，我会描述一下我见到过的网络数据抓取的生态，如语言，工具，SaaS 服务，网站反爬等。</p><p>这篇文章从我很久前做过的一个小例子出发，描述网络数据抓取的任务，可供选择的技术栈和我使用的工作流。在下文里，爬虫和网络数据抓取工具是同义词。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>需要得到王者荣耀所有英雄的名字。</p><p>描述看上去过于简单，但很多时候，一开始就定下<strong>获取所有 X 网页里面的 Y 元素</strong>可能会让你忘记你的真实目的是获取信息而不是为了写抓取脚本而写抓取脚本。有时候最快的方法是人力。如果不需要结构化数据，也许花一点时间人肉登记更快。</p><p><img src="../../../../images/pasted-0.png" alt="是否值得自动化"></p><p>为了增加例子真实度，再加入一点需求：</p><p>需要得到王者荣耀所有英雄的名字，和他们的资料。</p><h2 id="找到信息源"><a href="#找到信息源" class="headerlink" title="找到信息源"></a>找到信息源</h2><h3 id="现实情况1"><a href="#现实情况1" class="headerlink" title="现实情况1"></a>现实情况1</h3><p>如果确实需要自己获取这种数据，此时，先找到最权威的数据源。在这个例子里，最权威的是<a href="https://pvp.qq.com/web201605/herolist.shtml">官方网站里的英雄列表</a>。</p><p>现实中，该页面调用的一个 API 返回了所需信息的 JSON 。虽然我不知道这点，但我会使用下图的方法，利用 Chrome 的开发者工具，快速定位信息源。</p><p><img src="../../../../images/pasted-1.png" alt="用开发者工具调试王者荣耀资料的 API"></p><p>到这里，如果有了足够你需要的足够信息。基本上寻找信息源的这一步就结束了。</p><h3 id="虚构情况1"><a href="#虚构情况1" class="headerlink" title="虚构情况1"></a>虚构情况1</h3><p>在前后端分离火起来之前，一门语言适合做 Web 和适合渲染 HTML 几乎是等价的，毕竟大部分网站都用的是服务端渲染的技术。而到了今天，许多网站又开始通过使用 SSR 或 SSG 来增强 SEO 或是更好的利用 CDN，减轻客户端负担。</p><p>在以上的两种情况里，客户端只能看到一个 HTML 页面。如果要获取 HTML 上的元素，有两种定位的语言：</p><ol><li>XPath</li><li>CSS 选择器</li></ol><p>XPath 的优点是除了表达元素本身外，还可以提取出元素的属性或是用函数增强表达力。</p><p>CSS 选择器的优点是更加接近生产环境,这从 jQuery 和 document.querySelector 都使用CSS选择器就能看出。</p><p>这两种语言理论上我们也可以使用 Chrome 开发者自带的 copy selector/XPath 来获取，但我想推荐一款工具：<a href="https://github.com/fy0/EasySelect">Easy Select</a>:<br><img src="../../../../images/pasted-2.png" alt="Easy Select使用截图"></p><p>这款工具生成的 Selector 和 XPath 比起 Chrome 生成的质量上要好上不少。几乎不需要再人工微调。</p><h3 id="虚构情况2"><a href="#虚构情况2" class="headerlink" title="虚构情况2"></a>虚构情况2</h3><p>除了返回 JSON 格式的 API，以下种类的 API 我也遇到过：</p><ol><li>返回 JSONP 的 API</li><li>返回一整段 HTML/XML 的 API</li><li>使用 WebSocket 来与服务器通信</li><li>加密后的信息交换<br>使用开发者工具来人肉试验和筛选这些信息源，基本是唯一的办法。</li></ol><h2 id="从信息源获取信息"><a href="#从信息源获取信息" class="headerlink" title="从信息源获取信息"></a>从信息源获取信息</h2><p>从信息源获取信息，本质上是模仿人使用浏览器进行网络请求。模仿程度从低到高如下：</p><ol><li>能使用相同的协议通信。</li><li>能执行相同的行为，如自动保存Cookie，自动重定向等等。</li><li>能执行浏览器脚本，如页面上的Javascript。</li><li>无头浏览器。</li><li>受脚本控制的真实环境浏览器。</li></ol><p>如 cURL(sh/psh), http/superagent/axios(Node.js), urllib/requests(Python)等 HTTP 工具，基本都可以达到模仿程度2。一般来说，大部分的反爬也只需要你达到程度2的水平。</p><p>jsDOM(Node.js)达到了程度3，是 React 官方推荐的浏览器测试环境。如果开了CloudFlare 的浏览器检测功能，则需要至少达到这个程度。</p><p>Selenium，PhatomJS 达到了程度4。一般这时候除了没有显示，已经与真实浏览器无异。</p><p>我没有过需要程度5的情况，所以就不多说了。</p><h3 id="现实情况"><a href="#现实情况" class="headerlink" title="现实情况"></a>现实情况</h3><p>在这个小例子里面，你使用的工具只需要达到程度 1 就可以完成任务。</p><p>获得了英雄列表之后，再调用详情页中使用的API，就能获得英雄全部信息。</p><h3 id="虚拟情况"><a href="#虚拟情况" class="headerlink" title="虚拟情况"></a>虚拟情况</h3><p>如果有对于 IP 访问频率的限制，要么降低频率，要么使用IP池。</p><p>如果有对于登录的限制，则应该使用用户代理池。</p><p>Scrapy 这个框架，几乎能够满足模仿程度 2 以内所有的需求，比如在这个例子里，Scrapy 可以横向爬取英雄列表，再纵向进入英雄详情页抓取所有信息。</p><p>如果需要执行浏览器脚本，至少要使用模仿程度 3 以上的技术。</p><p>如果有验证码需求，则应该接入验证码管理，如自动打码平台等。</p><p>有的时候，众包是成本最低的方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一个步骤，描述需求，一定需要人工完成。</p><p>第二个步骤，找到信息源，一定要由人工完成。</p><p>第三个步骤，从信息源获取信息，我以为一般都要用人工完成，但是最近我使用了 Zyte 提供的 API 之后我发现现代的智能爬虫已经可以能够自动将信息结构化，后面的文章我也会用例子讲解。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>上文稍微描述了一下爬虫的相关技术栈和我的工作流。</p><p>之后几篇文章可能会围绕这两个主题:</p><ol><li>进阶：横向爬取和纵向爬取</li><li>使用 SaaS 工具 Zyte.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五个为什么</title>
      <link href="/2020/08/13/%E4%BA%94%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
      <url>/2020/08/13/%E4%BA%94%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>2020年8月10日深夜，我在 PTA 上开始做<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805320306507776"> 1005 </a>这道题。这道题不算困难，我在 1h 之内就实现出了一种解法，但我的问题不是这道题本身，而是我难熬的解题过程。</p><p>实现并提交之后，我<a href="https://pastebin.com/H3FT0gj7">第一个解法的实现</a>只通过了 5 个测试点中的 3 个，错误不是因为输出格式错误。有经验的人可能会立刻想到以下两种可能性（可能性由大到小排序）：</p><ol><li>边界条件导致算法失效。</li><li>算法（以及实现）的问题。</li></ol><p>首先是边界条件导致算法失效，我处理了数组越界（见 make_bitset 函数），而且我的算法没有边界条件，也没有出现计算误差，所以这一点不成立。</p><p>那么是算法及其实现的问题？我心中只有两个问题：</p><p>为什么还能有三个点对呢？</p><p>为什么我使用题目下面的输入样例没有问题，随便试了几个数据也没问题，最后却会出错呢？</p><p>这两个问题让我熬了2天夜，日思夜想，反复推演。最终我确信我的算法不仅没有错，而且还过度保险了，那么实现的哪个部分有问题呢？最后的最后，8月12日凌晨5点，我放弃了，并去找了这道题的题解。我看到题解中的实现和我的算法实现几乎一模一样，除了一句话<br><code>std::sort(...);</code></p><p>输入数据居然不是<strong>增序且不相同</strong>的？！我吓了一跳，看了一眼题目的输入格式：</p><blockquote><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个<strong>互不相同</strong>的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。</p></blockquote><p>啊，我好菜啊。</p><p>等等，我才看过<a href="https://book.douban.com/subject/4163938/">《 Joel 谈软件》</a>，里面有<a href="http://www.ruanyifeng.com/blog/2009/08/five_whys.html">文章</a>提到日本人发明的“五个为什么方法”来寻找根本原因。“我好菜啊”是表面原因，打个哈哈掩盖了根本原因。为了找到根本原因，我决定试用这个方法。那么，下面是我问自己的五个为什么：</p><p>为什么我整整花了两个凌晨来排查两个错误的数据点？</p><blockquote><p>因为我以为输入数据是有序的，而且我并不知道怎么排错。</p></blockquote><p>为什么？</p><blockquote><p>因为我看到了有序的输入样例。我看题面时又看到“互不相同”，所以产生了输入数据“有序且互不相同的印象”。同时，我并不知道自己是犯了什么样的错误，只能一遍遍的重复查看代码和 OJ 的结果。</p></blockquote><p>为什么？</p><blockquote><p>因为我认为这种题目可能刁难人的重心是放在算法代码实现上而不是在输入数据上，所以我预设了“输入数据的处理很简单”这件事，只草草看了看输入样例，而没有认真的看文字描述。同时，我太久没有做 OJ 题目了，已经忘记了我在 OJ 题目常犯什么样的错误。这种错误我之前肯定也犯过。</p></blockquote><p> 为什么？</p><blockquote><p>深夜做题可能会让我的理解力，记忆力下降吧，所以我才没那么仔细的读题。而且我早就应该把自己在 OJ 犯过的错误记录下来了，但之前没有记录。</p></blockquote><p> 为什么？</p><blockquote><p>我作息十分的不健康，而且深夜我才能静下心，所以才会深夜开始做 OJ 题。而且我之前懒得记录 OJ 常犯的错误。</p></blockquote><p> 为什么？</p><blockquote><p>可能是拖延症导致自己拖延自己的改变吧，而且太久没运动了意志力又消退了，事实上应该找一天好好的把作息调整过来。之前懒得记录是因为常做题有手感。所以，我应该要记录下来不常用的知识。</p></blockquote><p>问完这五个问题，我知道了我以后要解决的根本问题：多运动增强意志力，把作息调整过来来增强自己的理解力和记忆力，以及要把不常用的东西记录下来以免忘记。</p><p>这种对自身根本上的自省是一项很重要的能力，但是这个世界往往让人浮躁的难以自省，所以我要应该要重新做到“慎独”。在这个互相捧杀的世界里，大家已经习惯了用“大佬大佬”和“我真菜啊”来给各式各样问题打哈哈，但是我不应该限于打哈哈而是应该试着用“五个为什么”这样的方法来自省，这样获得的进步才是真实可持续的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译《重新审视 &lt;GOTO 语句被认为有害&gt;》的感想</title>
      <link href="/2020/02/10/%E7%BF%BB%E8%AF%91%E3%80%8A%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86-GOTO-%E8%AF%AD%E5%8F%A5%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%9C%89%E5%AE%B3-%E3%80%8B%E7%9A%84%E6%84%9F%E6%83%B3/"/>
      <url>/2020/02/10/%E7%BF%BB%E8%AF%91%E3%80%8A%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86-GOTO-%E8%AF%AD%E5%8F%A5%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%9C%89%E5%AE%B3-%E3%80%8B%E7%9A%84%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p><img src="../../../../img/paste/pasted-7.png" alt="goto"><br>Credit: <a href="https://xkcd.com/292/">xkcd</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>感谢 David R. Tribble 写的<a href="http://david.tribble.com/text/goto.html">原文</a>，有了这篇原文我才能翻译出<a href="https://www.emon100.com/goto-translation/">译文</a>。请勿随意转载。</p><h1 id="对原文的感想"><a href="#对原文的感想" class="headerlink" title="对原文的感想"></a>对原文的感想</h1><p>我认为正文分了四个部分，分别是:</p><ol><li>介绍和背景。</li><li>Dijkstra 的信与评注。</li><li>对各种结构化语言的分析与最后的总结。</li></ol><h2 id="介绍与背景"><a href="#介绍与背景" class="headerlink" title="介绍与背景"></a>介绍与背景</h2><p>介绍与背景中，作者阐明了那个时代的计算机科学与编程工作的状况，让我们在历史背景下的情况下讨论这封信。此处原文的总结已经足够丰富，所以不多说了。</p><h2 id="Dijkstra-的信与评论。"><a href="#Dijkstra-的信与评论。" class="headerlink" title="Dijkstra 的信与评论。"></a>Dijkstra 的信与评论。</h2><p>Dijkstra 论证 GOTO 语句有害的逻辑如下：</p><ol><li>因为程序员需要掌控程序流程，所以需要掌握程序流程的进度。</li><li>程序语言里有了结构化语句也还可以用各种方法表示程序流程的进度。</li><li>一旦滥用 GOTO ，有可能什么方法都没法表示流程的进度了。</li></ol><p>我能想到的 GOTO 的滥用有：</p><ol><li>用 goto 从一个循环跑进另一个循环。</li><li>直接离开子过程（C 语言里的 longjump）。</li></ol><p>这些滥用在 Dijkstra 的文中都被认为会破坏运行状态，导致流程进度不能被轻易地表示。</p><p>流程进度是这封信中的一个关键词，意思其实类似于语言的控制流或者执行过程。Dijkstra 认为程序员在编写程序的时候要对程序的各种可能执行过程保证了如于心才能少出问题，而滥用 goto 会让程序员难以分析执行过程。</p><p>Dijkstra 在文中也说将 goto 用于异常处理是合理的，而这篇文章还补充说明了用 goto 退出多层循环的合理性。如果没有合理的设施（如 Java 中用label标记的循环，try-catch 语句，RAII 等），有些情况下使用 goto 成为了提高程序表达能力的唯一方式。毕竟，这些设施的底层也是用机器码的 jump 指令实现的。</p><h2 id="对各种语言的分析与总结"><a href="#对各种语言的分析与总结" class="headerlink" title="对各种语言的分析与总结"></a>对各种语言的分析与总结</h2><p>的确，我们不应只是死板遵守某个不了解的规定而应当清楚地了解为什么和怎么做。而 David R. Tribble 的评论与补充让我们能够一瞥编程语言的历史背景和很多相关知识。</p><p>后面对语言结构的分析让我对程序语言的发展与结构有了更深的了解。作者讨论了很多语言的结构以及很多常用的编程时的使用 goto 的情况，对我来说可以算是大开眼界吧。</p><p>文章的最后部分的 LR parser 的例子给我带来了另一个启发：在模拟一个有限自动机的时候，使用 goto 来做状态转移应该也是一种描述状态转移的方式。</p><h1 id="翻译工作的感想"><a href="#翻译工作的感想" class="headerlink" title="翻译工作的感想"></a>翻译工作的感想</h1><p>最令我惊奇的是使用各种搜索引擎之后发现 Dijkstra 这篇经典的论文在中文世界只有两篇翻译，而且翻译的也不太好。这让我萌生了翻译 David R. Tribble 这篇文章的念头。在疫情肆虐大学生被迫待机期间，我终于有时间将翻译的愿望变为现实。</p><p>Dijkstra的正文比较晦涩且学术气浓重。我花了5天苦苦翻译加润色，最后得到了12000字长的中文文本。这么长的文本，看来也只有我这种放假的学生有时间无偿进行翻译。最终的成果我也只做到了正确的（自以为）传达原意而不能完全做到通畅，希望之后还能多次改进这个翻译。</p><p>翻译的工作第二难的是理解作者意思，第一难的是用<strong>恰当</strong>的母语表达出原文的意思。这次，我的遣词用句受到谷歌翻译的很大帮助，因为我发现谷歌翻译已经可以用改换句式等方法让翻译看上去更通畅。但有时谷歌翻译并不能理解文意从而翻译出通顺但意思完全错误的句子。换句话来说，谷歌翻译的<strong>唬人</strong>能力已经很出色了。</p><p>这次翻译过程中，我发现英文的伴随状语+各种从句挺难翻译的。一开始我用的方法是尽力把全部的意思塞进一句中文，后来发现这样很影响阅读。后来我采用了消除意义相同的定语+多分几个句子的方法。翻译质量我给自己打三颗星吧，译文可信，损失了一点点达但远远达不到雅。</p><p>此外，我在这次翻译中更加了解了“用爱发电”、“拖延症的解决在于立刻开始”等言论。我的人生中有了这件作品，应该也死而无憾了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github pages 使用个人域名+子域名+免费https证书最佳实践</title>
      <link href="/2020/01/28/Github-pages-%E4%BD%BF%E7%94%A8%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D-%E5%AD%90%E5%9F%9F%E5%90%8D-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/01/28/Github-pages-%E4%BD%BF%E7%94%A8%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D-%E5%AD%90%E5%9F%9F%E5%90%8D-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>github早在2018年5月1日就已经与<a href="https://letsencrypt.org/">Let’s Encrypt</a>合作，宣布支持对用户提供的个人域名颁发https证书。然而目前在国内搜索Github pages的教程时大部分的作者还停留在使用CDN颁发的证书的阶段。现在我来和大家分享我摸索出的一套使用个人域名+子域名+使用免费https证书的最佳实践。</p><p>本文假定读者已经成功部署了自己的网站且使用了子域名，但未使用Github提供的https证书以及未开启Github提供的https服务。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>步骤：</p><ol><li>特殊的修改域名解析以使得Github有条件给你一个https证书。</li><li>重启各个仓库的强制https选项让Github给你https访问功能。</li></ol><p>关键点是，Github需要你的域名解析CAA记录才能给你颁发证书，像我一样添加一项CAA记录：</p><table><thead><tr><th>域名</th><th>类型</th><th>值</th></tr></thead><tbody><tr><td></td><td>A</td><td>185.199.111.153</td></tr><tr><td></td><td>CAA</td><td>0:issuewild:letsencrypt.org</td></tr><tr><td>blog</td><td>CNAME</td><td>emon100.github.io</td></tr><tr><td>www</td><td>CNAME</td><td>emon100.github.io</td></tr></tbody></table><p>等待一段时间，域名解析记录刷新，这时可以去你的所有Github pages的仓库设置里把设置刷新：<br><img src="../../../../img/paste/pasted-5.png" alt="Github pages的设置"></p><ol><li>先把下面的custom domain删了保存。</li><li>enforce https关了，等待Github应用设置（之前打不开的话不管此条）。</li><li>再重新把原来的custom domain添加回去，enforce https打开，此时应该会看到Github提示你晚点设置会生效而不是之前的无法打开enforce https。</li><li>等待。</li></ol><p>等待之后之后你就会惊喜的发现你的域名可以用https访问了。</p><h1 id="优化访问速度最佳实践"><a href="#优化访问速度最佳实践" class="headerlink" title="优化访问速度最佳实践"></a>优化访问速度最佳实践</h1><p>使用CDN，如我使用了Cloudflare，注册个帐号之后，跟着指示做即可，很省心。使用之后打开网站和加载图片的速度变得非常快。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享Y-combinator（Y组合子）学习感想</title>
      <link href="/2020/01/26/Y-combinator%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/"/>
      <url>/2020/01/26/Y-combinator%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Y-combinator（Y组合子）"><a href="#什么是Y-combinator（Y组合子）" class="headerlink" title="什么是Y-combinator（Y组合子）"></a>什么是Y-combinator（Y组合子）</h1><p>TL;DR：一个输入一个<strong>匿名函数</strong>，输出为一个<strong>递归自己的匿名函数函数</strong>的函数是Y-combinator.</p><p><img src="../../../../img/paste/pasted-4.png" alt="Lambda 演算骑士团的徽章"></p><p>20世纪30年代，图灵的老师邱奇提出了lambda演算。由于数学对最简形式的要求，在这个系统中，所有的函数都没有名字（匿名函数），这就带来了一个问题：函数没有名字，怎么处理递归呢？</p><p>Y-combinator的出现就是为了解决这个问题，它的参数是一个因为需要<strong>调用自己</strong>的所以需要<strong>接收自己</strong>为参数的函数<strong>A</strong>，返回值是<strong>A</strong>的递归版本。</p><p>在理解这个的过程中，我对这种逻辑有了更深的体会。</p><h1 id="来点实例？"><a href="#来点实例？" class="headerlink" title="来点实例？"></a>来点实例？</h1><p>以下需要一些scheme知识。建议下载Racket来执行下面的代码，毕竟，肉眼配对括号还是比较困难。</p><p>先看一个有名字的递归函数length，这个函数的目的是为了输出链表长度：</p><pre><code class="scheme">(define (length l)  (cond ((null? l) 0)        (else (+ 1 (length (cdr l))))))</code></pre><p>或者为了之后研究的方便，我们写length的等价形式：</p><pre><code class="scheme">(define length    (lambda (l)   (cond ((null? l) 0)       (else (+ 1 (length (cdr l)))))))</code></pre><p>length是一个把链表的长度计算出来的函数。可以看到，函数执行过程中递归一层则链表长度+1。</p><p>现在我们怎样才能把这个函数改写为匿名函数呢？</p><p>首先，这个函数要变得需要调用自己，那么它得<strong>接收自己</strong>为参数，如下：</p><pre><code class="scheme">(lambda (length);length现在不是函数名字而是想接收的自己  (lambda (l)    (cond ((null? l) 0)        (else (+ 1 (length (cdr l)))))))</code></pre><p>有可能会有这样的想法：既然把自己传给自己就能递归了，所以Y-combinator只要做到这点就行了，于是写出了这样的代码：</p><pre><code class="scheme">(define Y (lambda (x) (x x)))</code></pre><p>但我将应用这个Y变换求长度的匿名函数后，得到的函数只能求长度小于等于1的链表起作用。</p><p>这时我突然懂了，你们如果看到下面的对长度小于等于3起作用的代码应该也会懂：</p><pre><code class="scheme">(define Y (lambda (x) (x (x (x x)))));                        ^  ^  ^                    把自己传给自己三次</code></pre><p>原来这样写并不够，我们还需要将这个内部的传值过程(自己传给自己)自动化扩展才能让这个函数具有无限递归的能力，我们好想让这个匿名函数自己内部也能应用一次参数，给予这个函数无限的递归能力。我们的目标就变为了先让函数被改成为如下这样：</p><pre><code class="scheme">(lambda (length)   ;这个length不只是这个函数本身了，   (lambda (l)     ;他是一个输入自己，返回自己的函数的代名词     (cond        ((null? l) 0)       (else (+ 1 ((length length) (cdr l)))))));                        ^      ^;               自己先自己传给自己，就能用前面的不好用的Y了。</code></pre><p>能做到吗？事实证明，这个操作是存在的：</p><pre><code class="scheme">;把函数加一层包装(lambda (mk-length)  ;这个新函数接受一个函数，返回这个函数  ((lambda (length)  ;注意看，把刚刚的匿名函数给代入了    (lambda (l)       (cond          ((null? l) 0)     (else (+ 1 (length (cdr l)))))))   (lambda (x) ((mk-length mk-length) x))))   ;上面这个括号是我给代入的匿名函数传的参数   ;注意，这括号有闭包。   ;返回值是一个 接受一个参数的函数</code></pre><p>如果实在看不懂，就把这个函数展开之后的样子写出即可看清了。接下来把代入的匿名函数部分化简为le，变为如下形式：</p><pre><code class="scheme">(lambda (le) (lambda (mk-length)      (le (lambda (x) ((mk-length mk-length) x)))))</code></pre><p>接下来就是把这个新函数自己传递给自己了。用这个重复：</p><pre><code class="scheme">(lambda (mk-length)      (mk-length mk-length))</code></pre><p>上面的两个代码片段你只需照如下步骤来应用就可以达成Y-combinator的目的：</p><ol><li>把原函数包装为一个符合要求的函数。</li><li>通过把自己传递给自己，把新的函数重复两次。</li></ol><p>示例：</p><pre><code class="scheme">(((lambda (mk-length)    (mk-length mk-length))     ;步骤2：让自己成为自己的参数  ((lambda (le)     (lambda (mk-length)      (le (lambda (x) ((mk-length mk-length) x)))))       (lambda (length);length现在不是函数名字而是想接收的自己         (lambda (l)           (cond ((null? l) 0)           (else (+ 1 (length (cdr l)))))))))           &#39;(1 2 3 4 5)) ;用&#39;(1 2 3 4 5)测试</code></pre><p>故我们已经知道了如何达成目的，现在让我们动手把<strong>包装</strong>和把<strong>自己当作自己</strong>的参数两个代码片段合二为一吧：</p><pre><code class="scheme">(define (Y le) ;定义Y为Y-combinator  &#123;(lambda (f) &#123;f f&#125;) ;&lt;-步骤2：让自己成为自己的参数   (lambda (f)     (le (lambda (x) &#123;(f f) x&#125;)))&#125;);                ^;                |步骤1：修改此函数</code></pre><p>这样，Y-combinator就做好了。</p><p>现在我们可以直接对函数fun应用Y-combinator <code>(Y fun)</code></p><h1 id="习题和解答"><a href="#习题和解答" class="headerlink" title="习题和解答"></a>习题和解答</h1><p>摘自<a href="https://yinwang0.wordpress.com/2012/04/09/reinvent-y/">王垠博客</a>的习题和我自己做出的解答：</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><blockquote><p>试着导出一个适用于两个互相递归函数的Y-combinator，函数可以为下面的形式：</p></blockquote><pre><code class="scheme">(define even  (lambda (x)    (cond     [(zero? x) #t]     [(= 1 x) #f]     [else (odd (sub1 x))])))(define odd  (lambda (x)    (cond     [(zero? x) #f]     [(= 1 x) #t]     [else (even (sub1 x))])))</code></pre><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>步骤为：</p><ol><li>先把互相递归函数弄成递归自己的函数</li><li>再应用上面的思想</li></ol><pre><code class="scheme">;The answer of;https://yinwang0.wordpress.com/2012/04/09/reinvent-y/;First, make mutual recursive functions into a directive recursive function(lambda (first second)  ;return a function which will accept a function itself(the directive recursive function)  (lambda (f-itself)    (first (lambda (x)             ((second f-itself) x)))));test((lambda (first second) (lambda (f) (first (lambda (x) ((second f) x))))) even1 odd1)((Y ((lambda (first second) (lambda (f) (first (lambda (x) ((second f) x))))) odd1 even1)) 8);poor man&#39;s(define (Y-mutual-poor first second)  &#123;(lambda (f) &#123;f f&#125;) ;&lt;-让自己成为自己的参数   (lambda (f)     (((lambda (first second) (lambda (f) (first (lambda (x) ((second f) x))))) first second) (lambda (x) &#123;(f f) x&#125;)))&#125;)((Y-mutual-poor odd1 even1) 8);final version(define (Y-mutual first second)  &#123;(lambda (f) &#123;f f&#125;) ;&lt;-让自己成为自己的参数   (lambda (f)     ((lambda (f) (first (lambda (x) ((second f) x)))) (lambda (x) &#123;(f f) x&#125;)))&#125;);Y-mutual final version test((Y-mutual even1 odd1) 8)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scheme </tag>
            
            <tag> SICP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《杀人回忆》观后感</title>
      <link href="/2019/11/22/%E6%9D%80%E4%BA%BA%E5%9B%9E%E5%BF%86%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2019/11/22/%E6%9D%80%E4%BA%BA%E5%9B%9E%E5%BF%86%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>剧透慎入</strong></p><p><img src="../../../../img/paste/pasted-2.png" alt="杀人回忆的台湾海报"></p><p>我在一节影视鉴赏课上看了《杀人回忆》。在接下来的数天里，即使我脑海里对此片情节的记忆越来越模糊，但观影时的感觉仍萦绕在我脑海中：希望不断破灭。</p><p>电影讲述警察侦办连环杀人案的过程。乡下的警察并未给人能够破案的感觉：证据意识的匮乏、严刑拷打嫌疑人、“靠脚办案”。而汉城警察的出现反倒是给了我希望：他尊重证据，嘴里总是念叨着“档案不会骗人”。在这看似套路化角色反差中，故事反套路的继续进行着。</p><p>雨夜还是有人遇害、抓到的嫌疑人都不是凶手、唯一目击证人被火车撞死。情节不断给观众吹起希望的泡泡再戳破。少女惨死，我与汉城警察都失去理性希望杀掉罪犯，可一纸DNA检测报告说嫌疑人不是罪犯，“档案不会骗人”，希望又破灭了。多年后回到麦田中，得知罪犯就是一个普通的人，宋康昊饰演的乡下警察，眼神一半无奈一半绝望，观众的心和他一样沉重。</p><p>找不到罪犯的缺憾与真实感反成了影片的最大魅力。奉俊昊导演讲了一个三十多年前的韩国故事，但我作为一个中国人依然能代入其中感受小城的人心惶惶、警察的无能为力和找不到罪犯的绝望，这种缺憾与真实感让人久久不能忘怀。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF初探——记中科大hackergame 2019（非二进制部分）</title>
      <link href="/2019/10/23/CTF%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%AD%E7%A7%91%E5%A4%A7hackergame-2019/"/>
      <url>/2019/10/23/CTF%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%AD%E7%A7%91%E5%A4%A7hackergame-2019/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://hack.lug.ustc.edu.cn/">Hackergame 2019</a> 是我参与的第一个信息安全竞赛。超长的比赛时长（7天）、题目覆盖了从网络到密码学到视频处理到逆向等等计算机领域的知识、极有竞技性的排行榜，这些特点让我这样的萌新也感受到了CTF的乐趣。期间我玩的乐不思蜀，一天查询资料10h+而且连续5天肝到凌晨2点。差点耽误正事。。。</p><p>说回正题，这次比赛中我还是学到挺多东西的，下面就按照题目给每道非二进制非数学题做一个总结吧。至于二进制，我正在用《程序员的自我修养》这本书来学习。</p><p>P.S. 少用百度多用 bing 用 google 用 youtube ，CSDN 的信息噪音在冷门问题前真的很大。</p><h1 id="已完成题目"><a href="#已完成题目" class="headerlink" title="已完成题目"></a>已完成题目</h1><h2 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h2><p>这是我的CTF处女题，一来就看到一个不能点的按钮，我之前的审查元素经验让我摁下F12，果然看到了这样的代码:</p><pre><code class="html">&lt;button data-v-52fd0931=&quot;&quot; disabled=&quot;disabled&quot;&gt;点击此处，获取 flag&lt;/button&gt;</code></pre><p>另外还有这种，这个比赛果然是面对像我这种萌新的:p</p><pre><code class="html">&lt;p hidden=&quot;&quot;&gt;其实只要把那个 button 的属性修改一下就可以了（&lt;/p&gt;&lt;p hidden=&quot;&quot;&gt;无论如何，欢迎来到第六届科大信息安全大赛！希望各位玩得开心。&lt;/p&gt;</code></pre><h2 id="白与夜"><a href="#白与夜" class="headerlink" title="白与夜"></a>白与夜</h2><p>题目之前给的提示特别明显，我一下子就发现这可能是需要把图片反色找文字，果然是这样！</p><h2 id="信息安全2077"><a href="#信息安全2077" class="headerlink" title="信息安全2077"></a>信息安全2077</h2><p><img src="../../../../img/paste/pasted-1.png" alt="http状态码"></p><p>题干提示HTTP/1.0。访问题目网页后发现是一个倒计时，看网络发现flag.txt显示了前提不满足的HTTP状态码。根据题目名字（2077）猜测可能要让服务器知道我在2077年访问这个网站，但是看到倒计时我看了看网页源码。</p><pre><code class="javascript">(function () &#123;      var now = new Date().toUTCString()...      fetch(&#39;flag.txt&#39;, &#123;method: &#39;POST&#39;, headers: &#123;&#39;If-Unmodified-Since&#39;: now, &#39;User-Agent&#39;: ...&#125;&#125;).then(function (res) &#123;...&#125;)</code></pre><p>代码已经提示了用If-Unmodified来判断，于是我去研究了一下发送HTTP自定义请求的方法，略微学习了python的request库后写出发送http的程序并获得服务器发送内容，确实有意思。</p><h2 id="宇宙终极问题"><a href="#宇宙终极问题" class="headerlink" title="宇宙终极问题"></a>宇宙终极问题</h2><p>第一问很简单，问你哪3个数字的立方和等于42，这是前几月的爆炸性新闻，随手<strong>百度</strong>到了。（没想到百度成为了我死掉的原因）</p><p>第二问让我找某8个数字的立方和等于某个指数，我又尝试<strong>百度</strong>并没有搜索到，于是放弃了。但是之后看题解发现原来可以随手<strong>Google</strong>到…</p><p>第三问因为第二问没做出所以没看到</p><h2 id="网页读写器"><a href="#网页读写器" class="headerlink" title="网页读写器"></a>网页读写器</h2><p>让我尝试访问一个服务器不让访问的网站 <a href="http://web1/flag">http://web1/flag</a> ，并友好的给出了服务端的源代码。重点就放在了检查服务器判断非法url的函数。</p><pre><code class="python">def check_hostname(url):    for i in whitelist_scheme:        if url.startswith(i):            url = url[len(i):]  # strip scheme            url = url[url.find(&quot;@&quot;) + 1:]  # strip userinfo            if not url.find(&quot;/&quot;) == -1:                url = url[:url.find(&quot;/&quot;)]  # strip parts after authority            if not url.find(&quot;:&quot;) == -1:                url = url[:url.find(&quot;:&quot;)]  # strip port            if url not in whitelist_hostname:                return (False, &quot;hostname &#123;&#125; not in whitelist&quot;.format(url))            return (True, &quot;ok&quot;)    return (False, &quot;scheme not in whitelist, only &#123;&#125; allowed&quot;.format(whitelist_scheme))</code></pre><p>根据函数，这个服务器会把url的@符号前的东西弄掉再判断url是否合法。哈哈，那我构造个参数里有个@符号的url不就行了。最终写出答案：<a href="http://web1/flag?=@www.example.com">http://web1/flag?=@www.example.com</a></p><p>BTW，这个服务器是一个 flask app，我正好复习了一下flask路由的写法。</p><h2 id="达拉崩吧大冒险"><a href="#达拉崩吧大冒险" class="headerlink" title="达拉崩吧大冒险"></a>达拉崩吧大冒险</h2><p>这个题使用到了 websocket，于是我去学习了一下，发现这是支持一种服务器可以主动向客户端发送信息的协议，而且和 HTTP 的兼容性很好，很有意思，而且 js 里自带 Websocket 对象，很好用，经过简单学习之后我感觉这道题应该是通过使用 websocket 来做一些事情操作服务器。后来根据检索到的某个 CTF writeup 获知 JavaScript 的整型有溢出的问题并且可以用这个方法弄服务器（ Python 也是动态类型语言，没这个问题啊，JavaScript 真救世语言）。于是我直接 ws.send() 狂发送负值给服务器，然后果然突然变成了正数，瞬间打爆大魔王。</p><h2 id="Happy-Lug"><a href="#Happy-Lug" class="headerlink" title="Happy Lug"></a>Happy Lug</h2><p>这道题我又被<strong>百度</strong>坑了，一开始已经找到了emoji域名，但是死活找不到DNS信息，我真的不太了解域名除了指向ip地址之外还能包含其他信息甚至一串<strong>TXT</strong>。所以做这个题既可以用一个好的搜索引擎获得好的DNS信息网站，也可以用nslookup来查询DNS。</p><h2 id="正则验证器"><a href="#正则验证器" class="headerlink" title="正则验证器"></a>正则验证器</h2><p>这道题我的奇怪思路是主函数的信号会在30s后触发信号导致进入打印flag的函数，但是事实上这是个利用<strong>正则表达式拒绝攻击</strong>**(regular expression denial of service)的题目，特定的正则表达式会需要指数级别运行时间。</p><p>Cloudflare有一次宕机就是因为这个，可以看他们写的这篇<a href="https://blog.cloudflare.com/details-of-the-cloudflare-outage-on-july-2-2019/#appendix-about-regular-expression-backtracking">博客</a>。</p><h2 id="三教奇妙夜"><a href="#三教奇妙夜" class="headerlink" title="三教奇妙夜"></a>三教奇妙夜</h2><p>用某种方法得到视频中的一些纯黑的帧即可。我这里使用的是ffmpeg的一个滤镜。这个滤镜会在命令行打印出静止画面的开始和结束实践，那么两个静止画面之间的就是 flag 画面了。我使用的命令如下：<br><code>ffmpeg -i output.mp4 -vf &quot;freezedetect=n=-60dB:d=2&quot; -f null NUL</code><br>这里最后的 NUL 是 Windows 上特殊的文件名，类似 Unix 中的 /dev/null，会将输出的文件丢弃。</p><p>命令行输出结果如下：</p><p><img src="../../../../img/paste/pasted-0.png" alt="命令行输出的结果"></p><p>或者使用以下命令将静止画面的开始和结束时间输出到文件:<br><code>ffmpeg -i output.mp4 -vf &quot;freezedetect=n=-60dB:d=2,metadata=mode=print:file=freeze.txt&quot; -map 0:v:0 -f null NUL</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
            <tag> Web </tag>
            
            <tag> C </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换变量：笨办法、加减法还是位运算？</title>
      <link href="/2019/08/01/%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%EF%BC%9A%E7%AC%A8%E5%8A%9E%E6%B3%95%E3%80%81%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%98%E6%98%AF%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%9F/"/>
      <url>/2019/08/01/%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%EF%BC%9A%E7%AC%A8%E5%8A%9E%E6%B3%95%E3%80%81%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%98%E6%98%AF%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在看 glibc 的 qsort 源码的时候发现交换变量的方式居然是定义了一个中间变量这种“笨办法”而不是加减法或者位运算！这让我有了疑惑，这三种交换变量的方式有没有高低之分呢？</p></blockquote><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>在编程中常常有交换变量的值的需求，比如说在排序中就常常要交换变量。经过思考人们思考出了三种交换变量的方法：利用一个中间变量；利用算术运算；利用位运算。下面对这三种方法利用C语言进行介绍和优劣势对比</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h3 id="法一：利用中间变量"><a href="#法一：利用中间变量" class="headerlink" title="法一：利用中间变量"></a>法一：利用中间变量</h3><p>代码如下</p><pre><code>int a = 1, b = 2, temp=0;temp = a;   a = b;   b = temp;</code></pre><p>这个方法是最初学的，清晰明了，所以大家也最爱用这个，可是很快人们发现了这个方法要多用一个变量，可能耗费了更多内存！于是乎人们又提出了接下来的两种不需要辅助变量的方法。</p><h3 id="法二：加减法"><a href="#法二：加减法" class="headerlink" title="法二：加减法"></a>法二：加减法</h3><p>代码如下</p><pre><code>int a = 1, b = 2;a = a + b;b = a - b;a = a - b;</code></pre><p>这个方法看似很美好，同样是三步，但现在所需要的变量少了一个，确实更好。但其实这个方法饱受溢出问题的困扰，试想a与b如果相加后导致溢出，那么第一步之后的结果都不一定对了。如下：</p><pre><code>char a=127;int b=1;a = a + b;b = a - b;a = a - b;</code></pre><p>如果你用 char 或者 int 类型的中间变量来交换a和b都不会出现错误结果，但加减法就会让a的值会错误的成为-1。</p><h3 id="法三：位运算"><a href="#法三：位运算" class="headerlink" title="法三：位运算"></a>法三：位运算</h3><p>代码如下</p><pre><code>int a = 1, b = 2;a ^= b;_//a与b异或，得到一个中间值，赋值给a_b ^= a;_//中间值与b异或，得到的是最开始的a，赋值给b_a ^= b;_//中间值与b（先前的a）异或，得到最开始的b，赋值给a_</code></pre><p>这个方法看上去无敌了，又不用中间变量，又无溢出之问题，简直是最完美的方法，那么学会这个方法之后就一直用这个方法吧。</p><p>但是为什么glibc这个大部分人都在用的C语言库的需要交换变量的qsort函数里不用这个方法呢？难道我们比GNU所有开发者30年的经验都聪明？</p><h2 id="隐藏的劣势与优势"><a href="#隐藏的劣势与优势" class="headerlink" title="隐藏的劣势与优势"></a>隐藏的劣势与优势</h2><p>位运算的方法其实有3个缺点：</p><p>1.在可读性方面：对于从未接触过这个方法的人来说，如果你不写注释，可能大家都看不懂你这里是想做什么。（当然对于GNU的人来说这个根本不算问题）</p><p>2.在性能方面：在过去可能用位运算比起用中间变量要快得多，但我们已经来到了21世纪。硬件上，如今的处理器在处理传送数据的MOV指令时都有<strong>MOV-elimination</strong>的特性，也就是说MOV这条指令可以做到<strong>0延迟</strong>（某种意义上），在各种情况下能做到<strong>至少</strong>和位运算一样快的交换变量速度。</p><p>同时，现代处理器有设计并行处理的流水线，但异或运算的时候运算的顺序是不可改变的，故完全无法利用这个特性可以带来的性能提升。</p><p>软件上，现代编译器会检测到你用中间变量做交换来判断你的意图来优化，优化后最糟糕的情况性能也和位运算一样。但是如果你做了位运算，编译器便为了保证安全而完全不敢优化。所以现在位运算看上去变成了<strong>性能较差</strong>的那个交换变量的办法。</p><p>3.最根本的，在行为本身的正确性方面，位运算其实也会出错：假如遇到了交换的内容在内存中储存在同一个地方的情况，比如我们对指针指向的内容进行交换，这时两个指针指向同一个内容是很容易发生的情况。然而用位运算的方法会完全把数据搞丢。想象一个指针a，b都指向同一个位置，之后指针指向的内容*a与*b交换，我们的预期是a,b指向的内容没有变化。但是如果使用异或交换的话，*a^=*a;直接会将*a清零，于是后面的操作变得完全没有意义了。为了解决这个问题，人们还要判断两个指针变量是否相同，于是需加上一句if(a!=b)，这时性能会下降的更厉害。但简单的用中间变量只要稍微注意交换次序便怎么滥用都完全没有出错的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用中间变量做交换吧，相信硬件和软件的优化。除了极端的缺乏内存以及你非常清除自己在做什么的情况下，不要使用奇技淫巧比如位运算（更不用提很明显有问题的算术法）来交换变量否则可能性能会损失或者丢失内容。</p><p>所以有一句话很对：不要过早的优化程序。我想，优化之前要明白在做什么优化，然后通过测试的方式评估来确认确实是优化了而且没有带来副作用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针和引用的终极书写规范</title>
      <link href="/2019/07/30/C++%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E7%BB%88%E6%9E%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"/>
      <url>/2019/07/30/C++%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E7%BB%88%E6%9E%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>我的代码规范：*，&amp;都应该放到变量名前面而不是类型名后，这样子在连续定义时有好处。</p><p><code>int* a;</code>✖</p><p><code>int *a;</code>✔</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><h2 id="一：指针与引用"><a href="#一：指针与引用" class="headerlink" title="一：指针与引用"></a>一：指针与引用</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>先明确一点，如int *a, a并不应该理解为指向int的指针，而应理解为int *类型的指针，所以指针的类型其实应该如下:</p><pre><code class="C">int * const int * //下面两个声明加了括号是由于编译器判断符号用了贪心法则，不加括号声明的意义会完全变化  void (*)(int,double)//函数指针声明范例//所以void (*ptr)(int,int)这种是声明一个返回值为void,参数为int，double的**函数指针**ptr //而void *ptr(int,int)声明了一个返回值为void *的**函数**  int (*)[10] //指向int[10]为基本单位数组的指针（行指针）//下面是一个恐怖的**函数指针+强制类型转换**的例子，摘自《C陷阱与缺陷》:(void (*)())0; //把0这个地址转换为void ()类型函数的地址</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><code>int &amp;p;//int类型的引用</code></p><p><code>int *&amp;p;//int *类型指针的引用</code></p><h2 id="二：const带来了难题"><a href="#二：const带来了难题" class="headerlink" title="二：const带来了难题"></a>二：const带来了难题</h2><p>明确了这些，现在加上const修饰符。如何判断常量指针和指向常量的指针还有常引用呢。  </p><h3 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a>指针</h3><p>其实只需要注意看const是在*的前面还是后面。  </p><p>const在*前面的情况，如</p><p><code>const int *a</code> </p><p><code>int const *a</code></p><p>其实是一个东西，都是<strong>指向常量</strong>const int 的指针<strong>变量</strong>，也就是说指针变量类型是 const int *.注意！这个时候指针变量是可以指向不同的位置的。</p><p>const在*后面的情况，如int * const a，意思是这是一个int *类型的指针<strong>常量</strong>。这个指针在初始化后不可修改。</p><h3 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h3><p>现在如果是引用，其实是一样的。我们要明确有两件事：  </p><p>1.只有<strong>指针的引用</strong>而没有<strong>引用的指针</strong>。只有常引用没有引用常量  </p><p>2.const int &amp;a 与int const &amp;a等价，因为反正引用也只能指向一个东西，这个const只是用来说明不能用引用修改原来的值。</p><p>我们是对某个类型声明引用变量，故&amp;前为这个引用的原本类型+可能存在的修饰符const  </p><p>按照上述规则来看看如何声明一个const int *类型的指针的引用</p><pre><code class="C">const int *a; const int *&amp;b=a; //声明完成 //这个引用意味着可以通过b修改指针a的值</code></pre><h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><p>const int * const &amp;b=a;//OK </p><p>int const* const &amp;b=a;//OK int * const &amp;b=a//NO!!这个意思是一个指向int *类型的常引用。不能用来引用const int *类型! </p><p>const const int * &amp;b=a;//NO！！！！两个const不能放一起</p><p>const类型的普通引用和常引用很容易弄混，但我们只需要明白一件事就好：int const &amp;a 与const int &amp;a等价（const和类型位置没什么关系），而编译器又读不懂连续的两个const。所以我们的方法是：  </p><p>1.如果发现引用的类型是const int*。 </p><p>2.就放置const到类型后面使得不会连续出现两个const  </p><p>所以我们在这里先放const int *(引用类型)再放const(表明常引用)。  </p><p>总结：指针和引用书写规范属于很trivial的东西，我关注纯粹是因为应试，结果研究了这么多，唉。</p><p>参考资料: <a href="https://www.cnblogs.com/chezxiaoqiang/archive/2012/09/24/2700241.html">https://www.cnblogs.com/chezxiaoqiang/archive/2012/09/24/2700241.html</a> (强烈推荐)</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 137与离散数学</title>
      <link href="/2019/07/06/LeetCode%20137%E4%B8%8E%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
      <url>/2019/07/06/LeetCode%20137%E4%B8%8E%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 </p><h2 id="https-leetcode-cn-com-problems-single-number-ii"><a href="#https-leetcode-cn-com-problems-single-number-ii" class="headerlink" title="https://leetcode-cn.com/problems/single-number-ii/"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">https://leetcode-cn.com/problems/single-number-ii/</a></h2><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>这个问题看似要记录每一个数字的出现次数。但是我看题目之前已经不幸看了题解所以知道这题一定是用位运算去做。于是问题简化成了找一个方法记录下某一位的状态，通过这一位出现次数来判断这一位的真假情况，具体次数与某一位的关系大概如下：</p><table><thead><tr><th>某一位出现次数</th><th>某一位的真值</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>1（1或0皆可，我用的是1）</td></tr><tr><td>3</td><td>0</td></tr><tr><td>n（不可被3整除）</td><td>1</td></tr><tr><td>n（可被3整除）</td><td>0</td></tr></tbody></table><p>比如3这个数，二进制位分别为1，1。这个数出现第一次时我要求二进制的两位分别为11，两次时我要求二进制分别为11，三次时分别变成00。</p><p>但是当你把某一位设置为1的时候，你无法知道这是这个数出现的第一次还是第二次，所以用一个变量给每个二进制位计数看来是行不通了。这个时候我又想起了题解，看来我需要第二个变量来储存每个位是出现了第二次还是第三次。所以算法如下：</p><p>以重复的数为3为例。设变量a（记录是否出现2次）,b（记录最终剩下的位）。第一次出现3时将b的两个二进制位变成11，a的二进制位保持00（因为每个位才出现1次）。第二次出现3将b的二进制位不变，而a看到b变为了11，便知道这是第二次了，于是将自己的二进制位变成11。第三次出现3时b注意到a之后便知道是第三次了，于是将两位分别置为00，a也知道这是第三次了，也变成00。</p><p>这个算法如何实现呢？这个时候就需要利用真值表了。然后用主析取范式！</p><table><thead><tr><th>a的位</th><th>b的相应位</th><th>某数的相应位</th><th>结果a</th><th>结果b</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>…</td><td>…</td><td>0（为0时a,b无变化）</td><td>…</td><td>…</td></tr><tr><td>0</td><td>0</td><td>1（第一次出现）</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1（第二次出现）</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1（第三次出现）</td><td>0</td><td>0</td></tr></tbody></table><p>最后b当然就是结果啦！</p><p>从这个计数器的设计这里我的第一次感觉到了离散数学是真实有用的hhh，感谢离散数学！</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我对图灵机的理解</title>
      <link href="/2019/05/13/%E6%88%91%E5%AF%B9%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/05/13/%E6%88%91%E5%AF%B9%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>2019年11月27日更新：之前没学计算理论，只学了计算机科学导论，确实对图灵机理解的很没深度。另外，我制作了一个通用图灵机的<a href="https://www.emon100.com/turing-machine/">演示</a>。</p><hr><p>下面采用自问自答的方法来叙述一些我的理解吧。</p><h2 id="1-图灵模型是什么"><a href="#1-图灵模型是什么" class="headerlink" title="(1)图灵模型是什么"></a>(1)图灵模型是什么</h2><p>在讨论图灵机之前，应该先讨论一下图灵模型。 图灵模型是用来定义通用计算机的模型。计算机是一个处理数据的黑盒，不去管这个黑盒的原理，只需要知道这个黑盒能够接受数据，处理数据，输出处理好的数据。图灵模型的定义了一种通用计算机，这种计算机可以在接受输入数据的同时接受处理数据的指令集合–程序。程序这个概念是图灵模型之创新，通用计算机的通用在此处得到了体现：只要接受不一样的程序，就能对数据做不一样的处理。</p><h2 id="2-图灵机是什么"><a href="#2-图灵机是什么" class="headerlink" title="(2)图灵机是什么"></a>(2)图灵机是什么</h2><p>接下来是图灵机，图灵机其实只是图灵提出的一个通用的计算模型，这个模型用了纸带来输入输出数据，而读头里自带程序。他为什么要用这种抽象的计算机器来描述通用的计算机呢？我觉得原因有二： 1.在图灵那个时代纸带是最好理解的储存器，所以他就用纸带来储存输入和输出的数据了。然后用一个“头”处理数据，就把计算机简化成黑箱了，方便描述。 2.他要用这个东西只是为了表达只要能提供数据和描述处理数据方式的程序就能用这种简单的通用图灵机计算，且也可以用更强大的通用图灵机计算，区别仅仅是计算速度。</p><h2 id="3-为什么图灵机重要"><a href="#3-为什么图灵机重要" class="headerlink" title="(3)为什么图灵机重要"></a>(3)为什么图灵机重要</h2><p>图灵机的重要在于他说明了一种通用的计算机只要有输入输出和程序部分就可以了。也就是在这种清晰的模型的定义下发展出了我们现在使用的更加方便的计算机模型：冯诺依曼模型。这个模型仅仅是对图灵机的硬件实现给具体化了然而就成为了现在最广泛应用的计算机模型，由此可见图灵机和其模型的重要性。 最早的电子计算机ENIAC就是很典型的图灵机，给计算机输入程序的方式并不是把程序以数据的形式在输入的时候提供给计算机而是在计算机运行前通过对电路重新连接以提供给计算机，这也印证了图灵机和其模型的重要性。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图灵机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何变得有趣</title>
      <link href="/2019/04/06/%E5%A6%82%E4%BD%95%E5%8F%98%E5%BE%97%E6%9C%89%E8%B6%A3/"/>
      <url>/2019/04/06/%E5%A6%82%E4%BD%95%E5%8F%98%E5%BE%97%E6%9C%89%E8%B6%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我明显变无趣了，你看我写的这篇博客都这么无聊。</p></blockquote><p>这个话题是之前和zyx聊到了自己不太说话了，之后聊天结束后自己延伸想到了自己的有趣程度这个方面。我觉得一个人的有趣程度的评估标准是与他人的交往时他人的愉快程度。所以如果你不与人打交道你可以毫无负罪感的做一个要多无趣有多无趣的人。但其实我感觉到我在和人聊天的时候越来越像个Siri一样没情趣没意思了，所以我决定反思一下。</p><p>我<strong>自认为</strong>我高三之后比之前的我无趣多了，<strong>可能</strong>原因有：</p><p>1.我不专注了。我无论是倾听还是叙述的时候很多时候其实都失去了专注力和记忆力。这个有一定的可能是因为长期的multi-tasking和使用手机对我的干扰导致的。</p><p>2.我不思考一些重大的社会问题了。初中的我曾经挺关注社会问题的，且常常仅凭借着自己小时候的科学和人文知识储备大放厥词。但高三看基辛格写的《白宫往事》，突然一下觉得国家领导人既需要幕僚辅佐又需要智库的帮助，普通人一般来说看问题真的比不过这些有顾问提供意见的领导人。我当时还觉得普通人就算如此还是要独立思考，但是好像自从觉得和别人分享这些不成熟的思考没什么意义之后好像就没怎么思考了。</p><p>3.我缺乏一个生活动机了，也就是兴趣。我不得不说我初三和高一的时候真的好热爱CSGO啊，曾经想过去科隆看NiP的比赛，或者退学去打职业。虽然没有真的做出这些举动，但是我是乐于想象的，啊现在很少有这种能让我做梦的机会了。</p><p>4.我懒得说话了。我现在的情况是可以说但懒得说，我本人是不怕在大众面前发言之类的，但是我就是懒得说话，结果现在不仅不想当众发言而且也跟周围的人说话说的少了，朋友圈和说说也很少发了。这个可能跟心理变化有关系，因为觉得之前高中说的太多做的太少所以上大学了想改变一下。</p><p>解决方法：</p><p>1.控制碎片使用手机，详见即将更新的后文，还有要减少multi-tasking的行为。综上我决定对注意力的分散进行记录与统计这样方便自我反思。</p><p>2.我懒得思考社会问题是因为觉得自己的知识量不够，但是我可以带着问题去寻找答案啊，所以还是多思考一下吧，说不定在某个领域我也能有顾问级知识深度和广度。</p><p>3.寻找兴趣。有兴趣，生活就有情趣了，详见前文。<a href="://blog.emon100.com/2019/01/18/%E6%96%B0%E5%B9%B4%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AF%BB%E6%89%BE%E4%B8%AA%E4%BA%BA%E5%85%B4%E8%B6%A3/">新年下一步：寻找个人兴趣</a></p><p>4.一个不说话的人确实是挺无趣的，不过我可以试着做到“语不惊人死不休”，这样也许用质变来弥补量吧。其实多与他人分享生活好像也不是什么让人感觉很“聒噪”的事情，所以也可以去试着这么做吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟自己说的话：少用手机</title>
      <link href="/2019/03/31/%E8%B7%9F%E8%87%AA%E5%B7%B1%E8%AF%B4%E7%9A%84%E8%AF%9D%EF%BC%9A%E5%B0%91%E7%94%A8%E6%89%8B%E6%9C%BA/"/>
      <url>/2019/03/31/%E8%B7%9F%E8%87%AA%E5%B7%B1%E8%AF%B4%E7%9A%84%E8%AF%9D%EF%BC%9A%E5%B0%91%E7%94%A8%E6%89%8B%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>作为一名智能手机的忠实爱好者，我从未想过这句话会有一天从我的嘴里说出。因为我曾经在无数个应该放下智能手机的时候都没放下：初三熬夜刷知乎的夜晚，高中周末躺在沙发上看手机的我，凌晨一点想着在看5分钟手机就睡然后看到了四点的我……诚然，智能手机可以满足我不论是找乐子还是分享生活还是学习东西的多种需求，然而<strong>我</strong>的不会适可而止已经使这些好处变成了我依赖智能手机的理由，因此，我要对自己说：少用手机。</p><p>为什么我要减少使用智能手机？ </p><ul><li>1.使用手机导致的整块时间的巨大损失，原本的整块时间被划分成了更多难以利用的碎片时间。尤其在我自制力差的情况下，重新划分我的碎片屏幕使用时间到大屏幕上是很有必要的。</li><li>2.智能手机在99%的情况中只是我的辅助IO工具。我只是用手机来输入信息(比如这篇文章)和获得一些娱乐，而手机本身的交流功能已经被弱化了，也就是说我其实99%的交流不需要智能手机。</li><li>3.手机让我没法真正的投入生活。我希望能够享受生活，而做个低头族其实并不能让我认真的去观察生活。</li><li>4.娱乐是必要的，但智能手机能带给我的大多是会迅速消减的无效娱乐。我不想做享受超常刺激的动物而是想做一个拥有心智的人。</li><li>5.比碎片化时间更恐怖的，是碎片化注意力，而智能手机确实导致了我的注意力集中度恶化了。我开始越来越难的集中注意力做好一件事，而是不知不觉中就切换任务。</li><li>6.放下手机我会有自我厌恶感。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker实践1：简单Flask app</title>
      <link href="/2019/02/25/docker%E5%AE%9E%E8%B7%B51%EF%BC%9A%E7%AE%80%E5%8D%95Flask%20app/"/>
      <url>/2019/02/25/docker%E5%AE%9E%E8%B7%B51%EF%BC%9A%E7%AE%80%E5%8D%95Flask%20app/</url>
      
        <content type="html"><![CDATA[<p>我想部署一个我很久之前写的一个其实不太好的Flask app，然而上次从凌晨3点开始部署到早上8点因为各种环境问题还是没搞定弄得我有点没信心。于是这次决定换一种方法：用docker来部署。</p><h2 id="为什么用docker"><a href="#为什么用docker" class="headerlink" title="为什么用docker"></a>为什么用docker</h2><p>首先，docker可以有效避免各种由于宿主机的环境导致的问题，比如说我的Ubuntu服务器上python2/3混杂，然后venv不知道怎么回事一直弄不好，然而换用docker之后只需制作好镜像即可在各个地方部署。同时docker的社区已经做起来了，有很多官方的image方便我这种弱手在上面打基础，文档也写得深入浅出。</p><p>其次docker可以很方便的把应用的规模放大缩小且做到流量均衡，同时镜像和容器管理也很方便，也有dockerhub这种镜像管理工具。</p><h2 id="操作步骤摘要"><a href="#操作步骤摘要" class="headerlink" title="操作步骤摘要"></a>操作步骤摘要</h2><p>1.安装，参见<a href="https://docs.docker.com/install/overview/">https://docs.docker.com/install/overview/</a></p><p>2.在应用的同目录下用一定的格式写Dockerfile再以此制作镜像。</p><p>3.直接部署。部署时把容器的端口映射到宿主机的某个端口上，这样才能从外部访问容器。</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>第一步还是略过，毕竟官方文档教的比我好。</p><p>第二步是要准备好你的Python程序。我这里是一个与官方例子较相似的flask web app，首先在此目录下用<code>pip freeze &gt;requirements.txt</code>创建依赖文件的记录，然后在程序目录下创建Dockerfile文件并填写以下内容。我这里是从官方文档复制的。</p><pre><code class="Dockerfile">    #将官方的python镜像当作base    FROM python         # Set the working directory to /app    WORKDIR /app        # Copy the current directory contents into the container at /app    COPY . /app        # Install any needed packages specified in requirements.txt    RUN pip install --trusted-host pypi.python.org -r requirements.txt        # Make port 80 available to the world outside this container端口看情况    EXPOSE 80        # Define environment variable    ENV NAME World        # Run app.py when the container launches    CMD [&quot;python&quot;, &quot;app.py&quot;]</code></pre><p>之后你可以用命令</p><p><code>docker built -t=&quot;你想要的tag&quot; .</code> （注意最后一个点不要省略，如果你需要push镜像建议tag打成username/repo:tag的格式）来制作镜像。</p><p>此时你再用docker images就可以看到自己的制作的镜像了。想运行的话直接使用命令</p><p><code>docker run -d -p</code> 映射到宿主机上端口:容器端口 之前的tag</p><p>命令用这个格式就可以在后台运行且端口被映射到宿主机上的一个端口。</p><p>接下来你就可以为所欲为了。</p><h2 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h2><p>我这里要做的特殊操作有：1.与宿主机SQL进行连接。2.容器内代码可能会更新。</p><p>第一个操作的做法比较简单：修改mysql的配置文件使其监听0.0.0.0，同时把程序中用来查数据库的账户的连接权限改成全网。我用的MySQL输入以下命令即可： </p><pre><code class="sql">grant all privileges on *.* to username@&#39;%&#39; identified by &#39;your password&#39;; FLUSH PRIVILEGES;</code></pre><p>应用程序内也相应把服务器地址修改为本机的IP而不是127.0.0.1可以了.</p><p>第二个操作的话给大家推荐一种简单方法</p><p>停止容器 <code>docker stop 容器id</code>，可以通过docker container ps 这条命令来查看容器id</p><p><code>docker cp &lt;container&gt;:&lt;dir of file&gt;  &lt;dir of file&gt; #把容器内文件拷贝到容器外一个位置</code></p><p>然后修改这个文件</p><p><code>docker cp &lt;dir of file&gt; &lt;container&gt;:&lt;dir of file&gt; #再把容器外一个文件拷进容器</code></p><p>最后再启动这个container即可</p><p>可以用这个方法来更新容器的程序文件的原理其实是因为每一个docker container有一个文件层，而container里的python实际上是在运行这个文件层的程序。</p><h2 id="工作流总结"><a href="#工作流总结" class="headerlink" title="工作流总结"></a>工作流总结</h2><p>用docker部署程序一般有这几步：</p><p>把东西配置好</p><p>写Dockerfile</p><p>Build 打tag</p><p>上传到云：login然后docker push</p><p>Run</p><p>跑到别的地方login pull 然后再run</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术研究 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache2转Nginx踩坑（2）：动态页面</title>
      <link href="/2019/02/05/Apache%E8%BD%ACNGINX%E8%B8%A9%E5%9D%91%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2/"/>
      <url>/2019/02/05/Apache%E8%BD%ACNGINX%E8%B8%A9%E5%9D%91%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>我已经把环境配置好了，https配置好了，重定向配置好了。现在要要做的是把存放在/var/www/wordpress的wordpress给配置好。如果你不知道我之前做了什么配置，请看前文<a href="/2019/02/05/Apache%E8%BD%ACNGINX%E8%B8%A9%E5%9D%91%EF%BC%882%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2/">Apache转NGINX踩坑（1）：静态页面</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>wordpress是基于php的博客软件，但Nginx并没有处理php的能力，故我们现在要利用Nginx的接口fastcgi调用解析PHP的php-fpm，这样我们就可以处理php了。</p><p>这里很多人直接借鉴网上教程，加上了location ~ \.php$以及后面的一大串，然而如果你想让你的网站的博客在二级目录下，你就会发现这个写法是有问题的，因为即使你写的多好，浏览器也只会一遍一遍的告诉你file not found. 正确的写法是在特定的location下写上那串代码，这样才能让nginx把正确的文件地址传给fastcgi. 下面是如果我想通过访问emon100.me/wordpress这个子目录来访问wordpress的正确操作：</p><p>找到有listen 443 ssl;的那个server区块，向里面<strong>添加</strong>以下内容，仍然用井号代表注释</p><pre><code class="Nginx">location /wordpress &#123;#指定寻找文件用的目录，我用的root，Nginx就会去/var/www/wordpress寻找#如果我想写的更加清晰易懂，可以写成alias /var/www/wordpress，但是#下面要额外配置    root /var/www;#官方文档推荐的wordpress配置    location = /wordpress/favicon.ico &#123;         log_not_found off; access_log off;     &#125;    location = /wordpress/robots.txt &#123;         log_not_found off; access_log off; allow all;    &#125;    location ~* \.(css|gif|ico|jpeg|jpg|js|png)$ &#123;        expires max;        log_not_found off;    &#125;    location ~ /\.ht &#123;        deny all;   &#125;    #关键来了，这里是寻找你的目录下以php结尾的文件，然后用fastcgi给php-fpm处理#请确保你在上一级已经声明过index index.php这个东西了    location ~ \.php$ &#123;        include snippets/fastcgi-php.conf;    #如果你前面不是root而是用了alias,请加上下面这句以保证可以正确的找到你要的文件    #fastcgi_param SCRIPT_FILENAME $request_filename;    #然后这句是传递给php-fpm，我用的php7.2，自行修改版本号        fastcgi_pass unix:/var/run/php/php7.2-fpm.sock;    &#125;    try_files $uri $uri/ /wordpress/index.php?$args;&#125;</code></pre><p>这样你就可以通过访问/wordpress子目录来访问wordpress了，当然你如果想把子目录改成/blog也可以，那么要把其中的root按照例子改成alias且按照指示改一下php区块下的内容。</p><p>以上是Nginx处理动态页面的一个例子。希望还是不要太依赖教程，多看看文档。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Apache2转Nginx踩坑（1）：静态页面</title>
      <link href="/2019/02/04/Apache%E8%BD%ACNGINX%E8%B8%A9%E5%9D%91%EF%BC%881%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/"/>
      <url>/2019/02/04/Apache%E8%BD%ACNGINX%E8%B8%A9%E5%9D%91%EF%BC%881%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要转"><a href="#为什么要转" class="headerlink" title="为什么要转"></a>为什么要转</h2><p>先说一下情况，环境是Ubuntu 18.04+LAMP，除了首页的静态页面之外我还有Wordpress和一个flask webapp. Apache2<strong>并不是做的不好</strong>，只是我遇到了2个<strong>我真的不想解决的问题</strong>导致我选择抛弃他：</p><p>1.我理解不能的文档。Apache2的文档是挺漂亮的。然而我一开始想把我的网站全面转成https时在官方文档里我根本找不到例子，（有例子，然而关键词根本不是example 而是我没意识到的How-to），然后要看懂后面的文档必须把前面的全部看懂，(因为不是例子)。最后我只好靠百度+CSDN在我的配置文件里添删改了无数内容在bash开启了不知道多少个apache2的模组才最终把https打开，最后可以说是莫名其妙It works. 相比之下Nginx的文档清晰的用例子告诉你跑过去在服务器配置文件里加两句ssl模组打开再加两句把证书位置指明然后就开了https了，真方便。</p><p>说到这又要说了，apache2.4是现在的最新版本，然而国内的资料，包括中文文档还停留在apache2.2，这说明如果我想上手apache2.4就必须去读官方英文文档，我当时没时间，现在有时间了，自然选择从零开始学习Nginx了。</p><p>2.我一直没看懂的配置文件语法。我真的难以理解apache2里面的rewrite规则之类的怎么写，这个其实不怪官方，怪我自己没仔细看文档，但也是因为这个原因，把wordpress部署到子目录这个很简单的工作花了我很长时间，把http流量301重定向到https也花了很长时间瞎改，这个被我瞎改改的臃肿的配置文件我已经无法忍受了。相比之下Nginx的配置文件就有条理多了。我看了一会文档里的例子和说明，然后举一反三很快就写出来了。</p><h2 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h2><p>在控制台输入以下内容：</p><pre><code class="shell">sudo /etc/init.d/apache2 stop</code></pre><p>以将apache2的服务停止，否则因为Nginx和apache2同时使用php可能会导致后面出现安装失败。</p><pre><code class="shell">sudo apt install Nginx </code></pre><blockquote><p>php-fpm(FastCGI Process Manager) 是一个用于在服务器和php后端数据交互的接口，让服务器（Nginx）直到，对于 *.php 文件，首先要给php解释器执行，然后把结果传回服务器，再返回给请求者。CGI实现了这个接口，FastCGI以更快地方式实现，而php-fpm也就是一个fastCGI的php官方版本。</p><p>我觉得之前LAMP一波装上apache2的应该不用另外装php-fpm，但如果不是的话请<br>sudo apt install php-fpm</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>ok，这下搞定了所有预备工作，接下来就是开始配置Nginx的工作了。首先是我的简陋的主页，这是一个静态网页index.html，存放在/var/www/html，用这个我们可以先测试https的配置是否正确，由于nginx默认是开着ssl模块的，所以我们可以写的很轻松。</p><p>进入/etc/nginx/sites-available查看配置文件default，里面给出了例子，这里我们来仿写和修改吧</p><pre><code class="Nginx">#井号开头是注释，这里用这个方法把下面仿写的解释清楚#server是Nginx里面的类似虚拟主机的概念server &#123;#原本有listen 80和listen[::]:80 我因为要使用https故#使用了下方监听了443端口的配置，这里用参数ssl声明所用的协#议，用default_server来说明这是默认的主机，#Nginx里每句话结束用分号    listen 443 ssl default_server;     listen [::]:443 ssl default_server;#ssl证书的存放位置，我这里填的我的    ssl_certificate     /home/emon100/emon100.me.crt;    ssl_certificate_key /home/emon100/emon100.me.key;#服务器的监听的url为这些，我填的我的    server_name emon100.me www.emon100.me;#声明主页文件类型为下面这些，由于我还要#配置wordpress故先加上index.php    index index.php index.html index.htm;#现在在书写访问根目录时的情况    location / &#123;    #声明根目录是哪个，用这个我们也可以把域名二级    #目录对应到服务器其他位置        root /var/www/html;    #Nginx有许多自带的变量，变量名前有$，此处为    #变量uri，如emon100.me/1/2/index    #那么uri就是/1/2/index，这里先把请求看做    #文件，再看做目录，再返回404        try_files $uri $uri/ =404;    &#125;&#125;</code></pre><p>写的过程中我们会发现作者提醒ssl如果开gzip那么会出bug，这里我们再打开<br>/etc/nginx/nginx.conf找到gzip改成off.</p><p>接下来我们可在bush输入nginx -s stop关闭nginx 再输入nginx 打开nginx，可以看到熟悉的主页了，且可以用https访问了。更进一步，未来所有的子目录都可能会用上https，所以我们要做两件事：</p><p>1.把证书应用到所有虚拟主机下。</p><p>2.把所有http访问301重定向到https去。</p><p>第一件事很好解决，只需要把ssl的证书位置那两行移到server的大括号外面即可，这样就是全局应用了</p><p>第二件事我们只需再开一个虚拟主机，无需使用rewrite，只需使用return（重定向功能）即可，在配置文件下再加上以下几行：</p><pre><code class="Nginx">server &#123;    listen          80;    listen          [::]:80;    server_name emon100.me www.emon100.me;    #第一个参数表示301重定向，后面是重定向    #之后的url，用两个变量组合应对各种可能    return 301 https://$server_name$request_uri;&#125;</code></pre><p>再用上面提到的两个命令重启nginx，用http连接一下主页，发现已经重定向到了https的网址。那么我们的任务1：应对静态网页就完美解决了！</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈我的佛系大学生形象</title>
      <link href="/2019/01/28/%E8%B0%88%E6%88%91%E7%9A%84%E4%BD%9B%E7%B3%BB%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%BD%A2%E8%B1%A1/"/>
      <url>/2019/01/28/%E8%B0%88%E6%88%91%E7%9A%84%E4%BD%9B%E7%B3%BB%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%BD%A2%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>19年伊始，我收到3位同学群发的手写个性化定制新年贺卡，上面除了有对我的祝福之外他们还稍稍的提了下我在他们心目中（正面的，能写给我看的）形象，感谢那三位同学的新年祝福，也谢谢他们为我提供了一个认识自己的视角。如果我稍微归纳一下我在他们心目中的形象，那么一个描述我的高频词汇呼之欲出：佛系青年。</p><p>其实我能够理解他们这样描述，因为其实上大学这三个月我基本上有意的：1.淡化社交（以前比较关注别人的做法和对自己的看法）。2.尽量降低自己的表现欲。这也能解释为什么没有大学之前认识我的人觉得我佛系但大学同学多认为我佛系，因为这两个做法可能导致别人对我不太了解，所以在他们心目中营造出了我是佛系青年的感觉。但是我想还想再深层的讨论下。</p><p>现代逐利社会让大家做事情更加重视效益。举个例子：在知道了许多人认为我是佛系青年之后，我跟同学说我要去运动以改变精神面貌，然而我同学却先想到提醒我运动完后发个说说以营造一种上进的个人形象（这就是人设？）。这个例子是如今浮躁社会的缩影：做了就说，说了再做，甚至说了不做，这些“说”的动作，才是社会主流，是社会逐利的方向，是人们认识你的窗口。也许这就是为什么抖音快手之类的软件兴起了吧，因为每个人都有着这种展现自己的表现欲望。而就是因为我不说，懒得说，没有展现自己的窗口而“被”成为了“佛系青年”。好玩吧，有的“佛系青年”们演着热血的自己，有的闷头苦干的热血青年们反而“被”佛系。解决方法也很简单，我的表现欲只要恢复到高二水平就好了，不过我暂时还想趁着自己还冷静着多做些脚踏实地的事。</p><p>他人用佛系描述我，可能是觉得我情绪很平静，不露声色，是一种中性的描述。但如果根据我的定义，佛系就有贬义意味了，所以我不会认为别人佛系，我自己也不自认为佛系，同时不会接受未来的自己变佛系。下面是我对佛系的定义：对事物都抱有无所谓的态度，就像一颗被割习惯了的韭菜任人宰割，丧失了奋斗精神，行尸走肉一样的平静。我讨厌这种生活态度，所以我不太喜欢佛系这个词。不过没关系，别人说我佛就佛吧，我知道自己不佛系就好了。</p><p>总结：做好自己，保持真实，我不佛系。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没看过爽文的人写的爽文</title>
      <link href="/2019/01/20/%E6%B2%A1%E7%9C%8B%E8%BF%87%E7%88%BD%E6%96%87%E7%9A%84%E4%BA%BA%E5%86%99%E7%9A%84%E7%88%BD%E6%96%87/"/>
      <url>/2019/01/20/%E6%B2%A1%E7%9C%8B%E8%BF%87%E7%88%BD%E6%96%87%E7%9A%84%E4%BA%BA%E5%86%99%E7%9A%84%E7%88%BD%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>2018年1月某日，我作为未阅读过任何网络小说的青年代表与几位喜爱在只能显示4行字的mp3阅读网络小说的同学讨论了天蚕土豆，我吃西红柿，唐家三少等著名网文作家的爽文，之后我们讨论了如何写出最爽的爽文，从头爽到尾，一位同学认为只有一开始被虐的够深才能在后面爽（SM?），我认为可以从头爽到尾，那位同学说你行你上，我说我行我上，最后大家都把这事忘了。今天我突然翻出来了那天之后写的爽文，放出来存档一下吧：</p><p>三个月后，我应当正坐在教室中拿着深一模答题卡，投影仪上的是我的考试成绩，总分660，全深圳至少也是前10名，语文120，数学130，英语140，理综270，同学们纷纷向我投来了羡慕的眼光，教室里一片片赞叹声中偶尔也传来几句“这简直不是人”之类的话，然而我只是深藏功与名继续学习。 六个月后，我离开考场，心中只有一个爽字，语文就拼阅读能力，依附我超级套路轻松解密，而作文我又胸有成竹。数学除最后一个填空全对，大题导数题一题一议，我笑着放弃。圆锥曲线和立体几何两个大题，我稳定得分。理综选择题40分钟拿下后发现物理实验题又是套路，化学生物又轻松拿下，笑着做完全卷。英语早就料到只考词汇，作文无敌套路早已准备好故完成不费吹灰之力，最后时刻字体一丝不苟，我露出了满分人士的微笑。 填好志愿，我写了本书叫做《打回重练》，讲述一人从重点初中堕到普通高中再驾鹤飞天考入名牌大学的故事，故事具有第一人称真实性，同时又有深刻内涵，被初中毕业生一致评为必读书籍。 最终录取结果公布我被梦想大学梦想专业录取，感到青春无悔。 （爽文完结，以上非作者真实情况纯属杜撰）</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的头像（多图）</title>
      <link href="/2019/01/19/%E6%88%91%E7%9A%84%E5%A4%B4%E5%83%8F%EF%BC%88%E5%A4%9A%E5%9B%BE%EF%BC%89/"/>
      <url>/2019/01/19/%E6%88%91%E7%9A%84%E5%A4%B4%E5%83%8F%EF%BC%88%E5%A4%9A%E5%9B%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/post_avatar1.jpg" alt="原版四兄弟图片"></p><p>原版意蕴深厚四兄弟</p><p><img src="/img/post_avatar2.jpg" alt="暗色头像"></p><p>一开始的暗色头像</p><p><img src="/img/post_avatar2.jpg" alt="高饱和度"></p><p>拉高饱和度后的第二版</p><p><img src="/img/post_avatar3.png" alt="非洲的自嘲少年"></p><p>描线第一版，来自非洲的自嘲少年</p><p><img src="/img/post_avatar_lownoise.png" alt="最终高清重制版"></p><p>意蕴深厚的步伐(最终高清重制版)</p><p>来源，湘教版地理七年级上册</p><p>总结：颜色越亮丽，心情越美丽。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年下一步：寻找个人兴趣</title>
      <link href="/2019/01/18/%E6%96%B0%E5%B9%B4%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AF%BB%E6%89%BE%E4%B8%AA%E4%BA%BA%E5%85%B4%E8%B6%A3/"/>
      <url>/2019/01/18/%E6%96%B0%E5%B9%B4%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AF%BB%E6%89%BE%E4%B8%AA%E4%BA%BA%E5%85%B4%E8%B6%A3/</url>
      
        <content type="html"><![CDATA[<p>胡适老先生曾经说过，大学生防止堕落有三个防身的药方：</p><blockquote><p>一、“总要有时间去寻一两个值得研究的问题”</p><p>二、“总得多发展一点非职业的兴趣”</p><p>三、“总得有一点信心”。</p></blockquote><p>关于第一点，我进入大学4个月以来时间有的是，但钻研过的问题后面都发现不值得钻研，等我未来学习也许有缘就会遇到几个值得钻研的问题了 。再说第三点，个人虽然感觉有点青春期无法自控矫情式抑郁（公益提示：抑郁不是抑郁症，勿把疾病当矫情），但是这个自信还是能做到的。仔细想想，现在我缺失的是第二步：发展个人兴趣。</p><p>关于我的个人兴趣的真相其实比较残酷。首先，我对兴趣爱好的概念很模糊，每次填写各种调查表我都难以在兴趣爱好那一栏里下笔。如果是让我填写坚持做的最久的事情，那我得填“上网”（有人不坚持上网吗？），如果填我喜欢的运动，那问题就来了，比如我喜欢极限飞盘，但是其实我高一之后就没玩过了，那我能说我爱好这项运动吗？</p><p>其次，我曾经很难善终一个事情，恶果积累到今天就是没有爱好。上一次对事情有很浓厚的兴趣还要追溯到初一玩航模，结果花了接近一千购买配件拼装两次试飞都坠机之后我甘于失败放弃了这项爱好，之后我好像就没有过爱好了。我钻研过各种各样的东西，比如动画，游戏，但现在甚至连番都不看了，也好久不看E3，TGS之类的会的报道了，现在看到很多人Cosplay或者手办或者模型或者摄影或者宅舞还有点羡慕他们真的有所热爱的事物。</p><p>最后，我喜欢做但谈不上热爱的东西太多了，比如我喜欢做视频剪辑，但是我剪辑久了之后就会感到烦躁，然后弃坑。再比如我喜欢听音乐，我喜欢阅读，我喜欢游泳，但我的热爱程度让这些东西远不能被称作爱好：我喜欢阅读，但一年也没看几本书，几乎全是碎片化阅读。我喜欢听音乐，但是我网易云一共只听过2500首歌，而且好像也只在听歌，不是欣赏音乐。我喜欢游泳基本等于喜欢夏天去玩水。你看，谈到热爱，我好像都没资格。没辙，每次让我填爱好，我基本都填鼓捣电脑或者阅读。有的人说，那你怎么不填玩游戏，对不起，连玩游戏这个曾经的爱好我都坚持不下去了…</p><p>总而言之，和小学那个有爱好有兴趣的我对比，我现在这个状态实在不利于身心健康。我每天只是忙于别人给我的事情例如学业，自己却没有值得自己奋斗的兴趣。认识到这点，我自从高考后的暑假就开始寻找自己的个人爱好了，可惜半年过去还没找到，新的一年，我其中一个愿望是找到自己热爱的事物为其奋斗。下面是我的规划：</p><p>1.提升体质以提升士气。我体质并不差，因为我还是能一次跑个5公里的，可惜高三的慢性疲劳让我至今还无法从（我也不知道是心理还是生理的）无力感恢复，不管怎么说，我觉得我体质还是有很大提升空间的。身体好，心情才好，希望自己多活动活动吧，最好能增重到70kg。</p><p>2.坚持知难而上的求知心和好奇心，由于我已经丢掉了很多东西，希望这些优点不要也丢掉了。然后希望遇到自己的弱点比如数学会去积极改进。我记得18年6月的时候我打字还是二指禅呢，坚持练习打字1个月后就能十指打字了，现在wpm都有60左右了。高三畏难是因为没时间，现在有时间就倾尽全力迎难而上吧。另外，好奇心应该对我找到兴趣帮助最大，因为人只有接触了足够多的东西才能发现自己的喜好。希望自己学习知识能更加系统一点，同时不忘多走走看看没接触过的世界，认识不同的人。</p><p>3.做事继续发扬坚持不懈的精神，我记得高三连续练了3个月字，这打破了我做不喜欢做的事情连续时长记录了，结果就是我的字稍微能看了一点，希望新的一年能继续多做这种半衰期长的事情。</p><p>4.做事善始善终，不要中途而废。这个是我现在才意识到的问题。由于现在信息爆炸，很多时候人不能完整的做一件事情，现在叫这个叫做“弃坑”，比如玩游戏弃坑，看书弃坑，一个事情一旦不符合喜好就直接去放一边不管了。其实我觉得完成大于完美。希望新的一年我不要“弃坑”，不喜欢的事情如果有益身心还是去完成吧。</p><p>说了这么多，去做才是更重要的，希望新的一年我能实现这些吧。最后是晚来的新年祝福，祝点进来的各位2019年新年快乐，心想事成！</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈慎独和捧杀</title>
      <link href="/2019/01/17/%E8%B0%88%E6%85%8E%E7%8B%AC%E5%92%8C%E6%8D%A7%E6%9D%80/"/>
      <url>/2019/01/17/%E8%B0%88%E6%85%8E%E7%8B%AC%E5%92%8C%E6%8D%A7%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<p>“慎独”二字被受人推崇是因为《礼记·大学》中说的“君子慎独”，下面摘自礼记</p><blockquote><p>《礼记·大学》第七章：“所谓诚其意者，毋自欺也。如恶恶臭，如好好色，此之谓自谦。故君子必慎其独也。小人闲居为不善，无所不至，见君子而后厌然，掩其不善，而著其善。人之视己，如见其肺肝然，则何益矣。此谓诚于中，形于外，故君子必慎其独也。 ”</p></blockquote><p>这段话白话是这个意思：</p><blockquote><p>心诚，就是不自欺。比如厌恶丑恶的，喜欢美好的，这叫自谦不叫自诚。所以君子要注重自我。小人在家闲居时什么坏事都可以做出来。当他们看到君子后，才会遮掩躲闪，藏匿他们的不良行为，表面上装作善良恭顺。别人看到你，就像能见到你的五脏六腑那样透彻，装摸作样会有什么好处呢？这就是所说的心里是什么样的，会显露在外表上。所以，是有德之人哪怕是在一个人独处的时候，也一定要谨慎。</p></blockquote><p>慎独，条件一是要不自欺，条件二是要做正确的事，条件三是独自一人的时候满足这些条件。在我看来，慎独不仅是成为君子的条件，也是判断君子的方法。看一个人的好坏，很多时候应该看这个人独处时，无法从众时的所作所为。</p><p>给大家举一个例子。中考之前的我喜欢从众，别人学我就学，别人不学我就玩。回了家宣称学习其实在电脑上看着番“顺便”写作业，写到凌晨也写不完只好去睡大觉。由于我是在自欺，故当时的我不够慎独。自然只能当一个眼高手低的不那么庸人而称不上是君子。高中的我好多了，虽然高一高二还是那个周末就疯狂打游戏不写作业的人，但是我不会再自欺了，学习不会和玩混着。甚至到高三寒假我第一次把自己关在了断网的电脑旁用着Anki整理着笔记，那时候我第一次感受到了慎独，这件事是我成长中也许效果微不足道但对心理状态改变特别大的事。</p><p>那时，语文老师出了一个关于“慎独”的作文题。想起我的经历，我对“慎独”这个词的轮廓突然感到熟悉，这个词从此融入了我的人生态度。</p><p>那时候我明白了，其实很多时候别人做的事你掌控不了也和你无关，你唯一能做的就是控制和掌控自己的事情，做好自己，就是慎独。</p><p>从此我开始觉得捧杀是个很糟糕的行为，因为这个行为不能帮助到任何人。我对捧杀的定义是：看到人做事就会过来发出两句明显不相称的赞美话从而让人不舒服甚至想吐的行为。我觉得“捧杀”别人，不是自私，就是自杀：捧杀人的人要么是强者嘲讽，在弱者奋力前进时用这种方式让他感觉到不舒服，从而达到阻碍他人的目的。要么是弱者嫉妒，自己无法掌控好自己的生活故使用这种方式去想掌控他人，要混大家一起混。</p><p>其实很多人已经被这种流行的病态校园文化所影响，你想奋力前行总会发现许多“捧杀”的人（大多是从众心理的锅）在阻挠。解决方案是什么？我觉得是慎独。一位著名的教育学家说过“一个人成熟的标志之一就是:明白每天发生在自己身上的99%的事情对于别人而言根本毫无意义”，他人不应该能够掌控你，只有你自己能掌控你自己，去做去说正确的的事物，对别人的nonsense无感，自己心里要有一个第三视角的自己审视自己的所作所为，给自己当秤砣。反过来也一样，你不能想着掌控他人。看到别人牛逼，别人在努力，不要嫉妒他们，捧杀他们，而是应该开始审视自己，提升自己， 去做事，不是在那BB。</p><p>现在，我正尝试做一个慎独的人，做事情尽量不从众，自己提升自己。最后呼吁各位，慎独，别捧杀。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对老电脑友好的Lubuntu系统体验</title>
      <link href="/2019/01/16/%E5%AF%B9%E8%80%81%E7%94%B5%E8%84%91%E5%8F%8B%E5%A5%BD%E7%9A%84Lubuntu%E7%B3%BB%E7%BB%9F%E4%BD%93%E9%AA%8C/"/>
      <url>/2019/01/16/%E5%AF%B9%E8%80%81%E7%94%B5%E8%84%91%E5%8F%8B%E5%A5%BD%E7%9A%84Lubuntu%E7%B3%BB%E7%BB%9F%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="配置与基本情况"><a href="#配置与基本情况" class="headerlink" title="配置与基本情况"></a>配置与基本情况</h3><p>先叙述安装过程之前先说说这台电脑的配置以及情况吧，这是我8月份时为了怀旧装的一台2006年中等配置机型：</p><p>CPU：Celeron D 单核2.8ghz</p><p>内存：DDR1 1GB x2</p><p>硬盘：Maxtor 80g x2</p><p>主板与显卡：915G主板 板载显卡Intel GMA600</p><p>这套配置可能看上去烂，但在2006年这个电脑可以玩CS1.6，魔兽世界，2003年前的大部分游戏，所以可以说是2006年的主流机型，同时这部电脑的很多配件也是我爸留下的，所以对我而言有很大的意义。唯一缺陷就是电源用的也是10年前的电源，当然这个电源是服务器电源，稳定的要命。最后当我装完系统体验了24小时之后（非连续使用），这台电脑寿终正寝了突然直接黑屏再也无法启动，拆机检验发现一个内存条的一小段金手指被烧掉了。声明一下，这件事绝对与这个操作系统无关，只是电脑寿命到了了，我之前也莫名其妙一通电就把和这个电脑同时期的硬盘烧的电感直接冒烟了。电子产品也是有其寿命的。</p><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>一开始我觉得电脑配置低，所以只敢装lubuntu推荐的的最低版本lubuntu 12.07，u盘备份好数据，使用官方推荐的easybsd制作启动盘，简单轻松，之后在老电脑上u盘启动进livecd即可。进去发现比想象中流畅的多，打开firefox看网站也没有了Win xp上的卡顿，只是因为cpu性能羸弱加载会慢一些。这时我觉得想试验一下极限，故下载了最新的lubuntu 18.04系统重新制作启动盘进行体验。我惊奇的发现系统并没有卡顿，而且也带了挺多好用的软件，于是我决定开始使用这个系统版本进行安装。</p><p>点击桌面上安装lubuntu的图标，由于我有两块硬盘，同时我又有把xp装在了硬盘1中，故我直接对硬盘二分区，将空余空间分一个250mb的/boot分区和/分区（就这个名字），然后最后选择把启动和系统都安放在硬盘二即可。安装好之后在bios切换默认硬盘即可启动。</p><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>这个系统自带的驱动很全面，居然能够在我这种奇葩环境下跑得动桌面，我觉得很好。系统自带的是LXQT桌面，据说比之前XFCE还要轻量，所以我使用时感觉还是满流畅的，系统自带了vim，libreoffice，vlc等软件，可以满足正常人的使用需求，当然我不够正常，于是我决定做两件事：</p><p>1.安装 spf13-vim</p><p>2.安装oh-my-zsh</p><p>在这个系统普通上上网听听歌写一点点代码都挺轻松的，然而干这两件事有点难，首先是系统自带的包严重不足，居然连<strong>curl</strong>都没有！所以安装软件包时依赖无数，其次是系统没有快速启动，故我每次不小心把qterminal关掉都要到无数级菜单下去重新打开。最后，这个系统没有类似控制面板的东西，所以很多设置没有图形化解决的方法。当然最后我还是把这些东西装好了试着写了一点代码，感觉流畅度还不错。后面我写着写着电脑突然炸了，那我也没法继续体验了。</p><p>总之，这个系统在轻量化这件事上做的非常不错，虽然简陋但是有框架，经过配置可以满足大部分人的主要需求。这是我第一次正经使用Linux当个人电脑的系统，体验不错，故给出好评。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矛盾与挣扎 —《如何高效学习》读后感</title>
      <link href="/2019/01/14/%E7%9F%9B%E7%9B%BE%E4%B8%8E%E6%8C%A3%E6%89%8E%20%E2%80%94%E3%80%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2019/01/14/%E7%9F%9B%E7%9B%BE%E4%B8%8E%E6%8C%A3%E6%89%8E%20%E2%80%94%E3%80%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>这是一篇本应2018年完成的读后感，然而我读完第一遍之后实在没有任何想写读后感的感觉，直到最近有空余时间把这个书又读了一遍才找到感觉，下面是我两遍阅读后的短评：</p><p>首先这本书讲的东西你都明白是对的，然而操作性很低，且讲的多是正确的废话，最后给人一种干货很<strong>湿</strong>的感觉。<br>其次，作者的能力太牛逼了，他好像与生俱来这种学习能力，所以我甚至觉得他写这本书是来嘲讽我们的。<br>最后，这本书的翻译实在太爱加戏了，阅读时会感觉很突兀。如果你想学学习方法，我推荐这个b站up主:<a href="http://space.bilibili.com/344849038/">YJango</a>。</p><p>下面是更细致的读书笔记：</p><p>这本书强调的概念是整体化学习，整体化学习分为获取，理解，拓展，纠错，应用，测试阶段。这本书购买的时候我正在一个高数直接上课听不懂预习也听不懂的难受时期，故我认为我是在学习的获取和理解上出了问题，下面我们来看看作者开的药方（药方已经过我的吸收）：</p><p>1.获取能力的提升方法：你可能是获取不到信息，这时候你应该用指读法，手指指着一点点读过去。你也有可能是获取太多，这时候你应该试试笔记流，把观点和结论简化记下来用箭头之类练习，然后课下再理解吸收。（我读完：WTF，哪有人看书看不懂啊，都是上课不知道老师讲的是啥听不懂啊）</p><p>2.理解能力提升方法：用联想法，用比喻法，用图表法，然后再内化。（我读完：我佛了，作者智商真的高，我要是也有这么猛的想象力能把抽象的东西全部想象成这么直观的就好了）</p><p>我读完整本书，首先开始矛盾：高数老师说上课听课效果拔群，然而我听不懂，那看书里的意思是应该让我下课搞？那难道我应该翘课？结果我开始挣扎：不是我听不懂，是我先决知识缺太多了，其实大家都一样，上高数不如自学。得，看完书我终于发觉自学才是出路。最后书中名言点题：理解不了就去找更好理解的材料。</p><p>尽管我喷这本书喷成这样，但我在书里还是学到些精华：</p><p>1.要把东西与实际联系起来，否则不与实际联系你必觉得乏味（我学高数就这个情况，学线代时好多了）。</p><p>2.找更好理解的材料（于是我开始看网课和国外的课本）。</p><p>3.费曼学习法，记录下你要学的中心概念，先看一遍书学一下，假装你是老师用白纸向学生解释，如果解释不通就回去看书，把解释记在纸上，最后简单化你的解释。</p><p>4.学会成为高效率人士（讲真的这本书把书名改成《如何维持学习力》我觉得会好很多）。</p><p>看完我这篇读后感，你就知道了书中的精华，别去买书了，去看作者博客吧: <a href="https://www.scotthyoung.com/blog/">Scott Young</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计一次维基百科编辑工作</title>
      <link href="/2018/12/28/%E8%AE%A1%E4%B8%80%E6%AC%A1%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E7%BC%96%E8%BE%91%E5%B7%A5%E4%BD%9C/"/>
      <url>/2018/12/28/%E8%AE%A1%E4%B8%80%E6%AC%A1%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E7%BC%96%E8%BE%91%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>这几天在回顾 the Beatles 个人最喜欢的一张专辑 Sgt. Pepper’s Lonely Hearts Club Band  ，从头到尾听了一遍之后例行工作当然是上各大网站去查查这张专辑的牛逼程度以此来告诉自己：我听歌品味也太好了吧。这次中间出了点小插曲，我看到这张专辑的中文 wiki 页面上某章节居然出现了错别字：Sgt. Pepper 也就是佩珀中士被写成了佩珀重视。我听的专辑这么牛逼，wiki 怎么能有错别字？于是我便第一次开始尝试编辑维基页面。</p><p>第一步我就被吓到了：任何人都能编辑没有被保护的wiki页面，不用注册任何账号， 维基百科的口号“自由的百科全书”名副其实，这简直就是对需要注册账号才能编辑但许多页面的质量仍然不甚理想的百度百科最大的嘲讽。虽说可以直接登记ip地址编辑，但我有着小小的虚荣心，希望这项编辑可以记录在我名下，于是我决定注册个账号再编辑。</p><p>编辑过程有两种做法:代码编辑和可视化编辑，我选择后者因为后者不用预览更改就可以提交。然而这个编辑过程由于某不能说的长城非常卡顿。编辑完成后又因为糟糕的网络状况频频提交失败，最后没想到居然默认我没登录直接把这项编辑用ip地址提交了…</p><p>虽然说这项编辑没有记在我的名下，但我还是为世界的知识共享做了一点好处，因为这种小事可以改变后人的阅读体验。前人种树后人乘凉，这样想了之后感觉自己形象高大了许多。</p><p>最后还是给大家推荐一下 Sgt. Pepper’s Lonely Hearts Club Band 这张滚石500排名第一的专辑吧。可能很多人觉得这张专辑旋律没那么琅琅上口，但不可否认的是这张专辑在实验性和商业性间做了很好的平衡。这张专辑实验了很多当年新兴的录音手法比如无间断连续播放两首歌，还有很多摇滚里的第一次如使用各种新奇的乐器比如印度的乐器，专辑的封面设计也是超越时代的。这张专辑获得滚石排名第一可以说实至名归。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于C语言中链表的感想</title>
      <link href="/2018/12/11/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%84%9F%E6%83%B3/"/>
      <url>/2018/12/11/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>今天学了一种基础的数据结构，链表。其实我学习链表的兴趣主要来自思考如何解决约瑟夫环及其相关的需要记录状态的问题的解法。 （其实约瑟夫环有一种简便的递归解法<a href="https://blog.csdn.net/yanweibujian/article/details/50876631">https://blog.csdn.net/yanweibujian/article/details/50876631</a>） 链表是什么？在我的理解中，这就是一种不连续的数组。每一个元素或者部分（链表中叫结点）由指针来记录位置或者指向，用链表的好处就是可以防止用数组导致的内存空间浪费或者不足（如果使用动态链表）。下面我来说说我踩的坑。<br>Typedef</p><hr><p>我们在使用链表时经常会遇到这种情况： 于是这个时候我就想，后面也要用到man这个数据类型，不如用typedef 这样就再也不用写struct了。 于是写成这样 </p><pre><code class="C">typedef struct man&#123;… Person *next; &#125;person;</code></pre><p>然而这样子是不行的，因为typedef要编译之后才有类型person，所以不行。 解决办法是写成这样: </p><pre><code class="C">typedef struct man&#123;     ...    struct man *next;    &#125;person;</code></pre><p>此时person 和 struct man等价。<br>链表需要用malloc函数</p><hr><p>这里不多说了,居然需要用强制类型转换将函数返回的void *指针转换成我要的person *类型。明明谭浩强说不用。<br>sizeof()原来是一个运算符而不是函数</p><hr><p>sizeof()这个跟宏定义一样也是在编译之前就会把值给算出来的，我今天才知道。 </p><p>第四个坑是环形链表和单向链表，双向链表的实现。具体的可以再写一篇文章了，不多说了。 </p><p>第五，第六个坑我还没解决，不过好像暂时没什么问题。第五个坑也就是如何释放每个节点，尤其是环形链表的释放，这个东西到时候再说吧。第六个坑就是链表的节点的插入，删除，要考虑头，中间，尾各种情况，在此做个记录，下次要完全搞懂。 最终我终于实现了这个约瑟夫环问题。今天成就感还不错。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将我的网站从Http转到Https</title>
      <link href="/2018/11/24/%E5%B0%86%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%E4%BB%8EHttp%E8%BD%AC%E5%88%B0Https/"/>
      <url>/2018/11/24/%E5%B0%86%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%E4%BB%8EHttp%E8%BD%AC%E5%88%B0Https/</url>
      
        <content type="html"><![CDATA[<p>昨天是黑色星期五，我原准备买一个便宜点域名和一个新的VPS，然而Namecheap和Bandwagon的促销活动都萎的不行，个人猜测可能是因为受到了贸易战的影响。于是只好使用GitHub的学生包领取了一个长达一年的.me域名和一个长达一年的SSL证书。下面我来写写步骤。</p><p>服务器环境：LAMP Ubuntu18.04 Wordpress</p><p>首先是参照的教程<a href="https://www.digitalocean.com/community/tutorials/how-to-install-an-ssl-certificate-from-a-commercial-certificate-authority">https://www.digitalocean.com/community/tutorials/how-to-install-an-ssl-certificate-from-a-commercial-certificate-authority</a></p><p>其实很简单，重点步骤是1.申请证书</p><p>2.修改Apache2的配置   </p><p>3.修改wordpresss的配置</p><p>申请证书不多写了，这个过程可以单独写一篇文章，去百度搜索Namecheap申请证书或者看上面的文章就可以了。注意生成CSR的时候要把common name填写成自己的域名，然后在申请的时候DCV Methods in Use建议使用DNS，这样只要根据要求设置指定CNAME和映射几分钟就能把证书给你。之前我用的大家推荐的Email方法，非常慢。</p><p><img src="http://blog.emon100.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png"></p><p>password已经打码了，这是生成csr的时候</p><p>之后就是把证书传进服务器。要传入一个好找的位置，我是跟csr和key放在一起的。之后再设置Apache2的设置，和301重定向，不多写了，上面的教程也有。</p><p>最后是设置wordpress，我用的phpadmin来设置，将wordpress数据库中wp-options中home和siteurl都设置为带https的url即可正常访问wordpress。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任务1：王者荣耀</title>
      <link href="/2018/11/11/%E4%BB%BB%E5%8A%A11%EF%BC%9A%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/"/>
      <url>/2018/11/11/%E4%BB%BB%E5%8A%A11%EF%BC%9A%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/emon100/King-glory-data">https://github.com/emon100/King-glory-data</a>  </p><p>这周考试堆积，导致到了周日晚上才能找到一些自己的时间学习了。  </p><p>本人其实很喜欢这种具有时间期限的学习方式，因为可以让我的大脑快速进入状态。上一次接触Python还是6-7年前看的父与子的编程之旅那本书了，当时还是Python2.7。现在3.7了，约等于重新开始学习，不过我还是很有信心的。  </p><p>然后去图书馆借了一本《Python网络数据收集》和《Flask Web开发》，到时重点看吧，这几天实在要考试。  </p><p>runoob.com这个网站很有用。</p><p>最后，具体的TODO list已经放在github上面了，希望可以完成吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典例题-个位数统计</title>
      <link href="/2018/11/06/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
      <url>/2018/11/06/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019.6.7更新:我觉得我之前写的是纯垃圾代码，不过这个不能怪我，我那个时候还没接受正规的训练，代码屎非常正常。得到的教训是，时常重构代码可以有效提高代码质量。</p><p>下面是我3分钟写的新版个位数统计</p><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    char a[1000];    int  num[10]=&#123;&#125;;    scanf(&quot;%s&quot;,a);    for(char *p=a;*p!=&#39;\0&#39;;p++)&#123;//Bitmap        num[*p-&#39;0&#39;]++;    &#125;    for(int i=0;i&lt;10;i++)&#123;        if(num[i])            printf(&quot;%d:%d\n&quot;,i,num[i]);    &#125; &#125;</code></pre><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>简单版算法：<br>1.得到字符串。<br>2.得到字符串长度。<br>3.判断数组那些是0，1，2…需要遍历10次，分别统计输入。同时输出。<br>好的地方：善用数组相关函数，简便，很容易改造成多数据输入版,只需要通过将scanf外加一个判断EOF的while和每次输出结束后将b还原为’0’.</p><p>首先上简单版 </p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main() &#123;    int n,i,j;    char a[1000],b=&#39;0&#39;;    scanf(&quot;%s&quot;,a);   i=strlen(a);    while(b&lt;=&#39;9&#39;)&#123;//统计1~9每一个数字出现次数         n=0;        for(j=0;j&lt;i;j++) &#123;        if(a[j]==b) n++;         &#125;         if(n!=0)             printf(&quot;%c:%d\n&quot;,b,n);//如出现次数不为0，输出       b+=1;     &#125; return 0; &#125;</code></pre><p>我写的版本1 1.输入一个字符 2.判断一次0-9，记到i0-i9，判断是否能输出 3.继续，直到’\0’判断结束,输出一个值代表能输出 4.输出一次，重新初始化,再重复循环 好的地方：其实可以没必要用数组，一个值就够了。 缺点：多出了字符个数次+1次能否输出的判断。 变量个数过多。</p><pre><code class="C">#include&lt;stdio.h&gt;int main()&#123; int i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,u;i0=0; i1=0; i2=0; i3=0; i4=0; i5=0; i6=0; i7=0; i8=0; i9=0;/*我要做的： 首先用重复多组输入，输入到c 然后直接判断个数？输出一次？然后再输入一次再 */ char c[1001];for(int i=0;scanf(&quot;%c&quot;,&amp;c\[i\])!=EOF;i++)&#123;    for(u=0;u&lt;1;u++)&#123;    switch(c\[i\])&#123;    case&#39;0&#39;:i0++;break; case&#39;1&#39;:i1++;break; case&#39;2&#39;:i2++;break;    case&#39;3&#39;:i3++;break; case&#39;4&#39;:i4++;break; case&#39;5&#39;:i5++;break;    case&#39;6&#39;:i6++;break; case&#39;7&#39;:i7++;break; case&#39;8&#39;:i8++;break;    case&#39;9&#39;:i9++;break; case&#39;\n&#39;:u=2;break;     &#125;     if(u==2)&#123;        if(i0!=0)printf(&quot;0:%d\n&quot;,i0);      if(i1!=0)printf(&quot;1:%d\n&quot;,i1);       if(i2!=0)printf(&quot;2:%d\n&quot;,i2);       if(i3!=0)printf(&quot;3:%d\n&quot;,i3);       if(i4!=0)printf(&quot;4:%d\n&quot;,i4);       if(i5!=0)printf(&quot;5:%d\n&quot;,i5);       if(i6!=0)printf(&quot;6:%d\n&quot;,i6);       if(i7!=0)printf(&quot;7:%d\n&quot;,i7);       if(i8!=0)printf(&quot;8:%d\n&quot;,i8);       if(i9!=0)printf(&quot;9:%d\n&quot;,i9);      i=0; i0=0; i1=0; i2=0; i3=0; i4=0; i5=0; i6=0; i7=0; i8=0; i9=0;         &#125;  &#125; &#125; return0; &#125; </code></pre><p>我参考简单版后写的版本二 1.直接输入数组 2.直接判断 3.其他地方跟版本1一样 </p><pre><code class="C">int main()&#123;charc[1000];intu,n,v; inti0,i1,i2,i3,i4,i5,i6,i7,i8,i9; i0=0; i1=0; i2=0; i3=0; i4=0; i5=0; i6=0; i7=0; i8=0; i9=0; n=0; v=0; while(scanf(&quot;%s&quot;,c)!=EOF)&#123; for(n=0;c\[n\]!=&#39;\\0&#39;;n++) for(u=0;u&lt;=n;u++)&#123; switch(c\[u\])&#123; case&#39;0&#39;: i0++; break; case&#39;1&#39;: i1++; break; case&#39;2&#39;: i2++; break; case&#39;3&#39;: i3++; break; case&#39;4&#39;: i4++; break; case&#39;5&#39;: i5++; break; case&#39;6&#39;: i6++; break; case&#39;7&#39;: i7++; break; case&#39;8&#39;: i8++; break; case&#39;9&#39;: i9++; break; case&#39;\\0&#39;: v=2; break; &#125; if(v==2)&#123; if(i0!=0)printf(&quot;0:%d\\n&quot;,i0); if(i1!=0)printf(&quot;1:%d\\n&quot;,i1); if(i2!=0)printf(&quot;2:%d\\n&quot;,i2); if(i3!=0)printf(&quot;3:%d\\n&quot;,i3); if(i4!=0)printf(&quot;4:%d\\n&quot;,i4); if(i5!=0)printf(&quot;5:%d\\n&quot;,i5); if(i6!=0)printf(&quot;6:%d\\n&quot;,i6); if(i7!=0)printf(&quot;7:%d\\n&quot;,i7); if(i8!=0)printf(&quot;8:%d\\n&quot;,i8); if(i9!=0)printf(&quot;9:%d\\n&quot;,i9); u=0; n=0; i0=0; i1=0; i2=0; i3=0; i4=0; i5=0; i6=0; i7=0; i8=0; i9=0; &#125; &#125; &#125; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何通过设置使得wordpress需通过访问域名下子目录才可访问</title>
      <link href="/2018/10/24/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E4%BD%BF%E5%BE%97wordpress%E9%9C%80%E9%80%9A%E8%BF%87%E8%AE%BF%E9%97%AE%E5%9F%9F%E5%90%8D%E4%B8%8B%E5%AD%90%E7%9B%AE%E5%BD%95%E6%89%8D%E5%8F%AF%E8%AE%BF%E9%97%AE/"/>
      <url>/2018/10/24/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E4%BD%BF%E5%BE%97wordpress%E9%9C%80%E9%80%9A%E8%BF%87%E8%AE%BF%E9%97%AE%E5%9F%9F%E5%90%8D%E4%B8%8B%E5%AD%90%E7%9B%AE%E5%BD%95%E6%89%8D%E5%8F%AF%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>我的条件：服务器系统ubuntu 18.04 apache2 且之前在000-defaulf.conf中设置根目录为/var/www/wordpress/ </p><p>设置一共3步： </p><p>1.去wordpress设置中将博客地址改为http://域名/wordpress </p><p>2.此时域名已无法访问，此时去找到你服务器上apache2的sites-available中的000-default.conf 将document-root改为wordpress的上级目录，此处为/var/www/ </p><p>3.shell里输入 sudo systemctl restart apache2 目的是重启apache2 打开 http://域名/worepress ，发现此时已可以访问。 如果操作失败，则各项刚刚修改的项目均需还原修改前的样子并看我前文教程来恢复对wordpress的访问。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么我没学金融，经济学</title>
      <link href="/2018/10/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E5%AD%A6%E9%87%91%E8%9E%8D%EF%BC%8C%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
      <url>/2018/10/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E5%AD%A6%E9%87%91%E8%9E%8D%EF%BC%8C%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>1.2018年了，距离金融海啸过了10年，你觉得呢？美股都涨了8年了，不如在大学等牛市投机交易。</p><p>2.2018年，A股暴死。</p><p>3.技术永远有饭吃（虽然也有可能一辈子无法暴富）</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018.10规划</title>
      <link href="/2018/10/23/2018.10%E8%A7%84%E5%88%92/"/>
      <url>/2018/10/23/2018.10%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>从今天开始我将会使用TICKTICK这款软件进行时间管理了，故这个笔记本以后不会再有清单类的任务了，以后只会有一些我对大方向的思考。 接下来我来理清我的时间规划清单的用法 首先每天把所有要做的事放在inbox里之后马上归类或者晚上冥想后归类 首先是每天必须做完的任务:</p><ol><li> 日程表，用于做必须当天做完的事情</li><li> 日计划 包括日程表，推荐当天可以做的非紧急高收益事件</li><li> 累了做一些 小事清单里面的事</li></ol><p>每天除了日程表，还要做1-3件高收益不迫切的事</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我把wordpress后台的站点地址修改后无法正常访问的解决办法。</title>
      <link href="/2018/10/09/%E5%85%B3%E4%BA%8E%E6%88%91%E6%8A%8Awordpress%E5%90%8E%E5%8F%B0%E7%9A%84%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9D%80%E4%BF%AE%E6%94%B9%E5%90%8E%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E3%80%82/"/>
      <url>/2018/10/09/%E5%85%B3%E4%BA%8E%E6%88%91%E6%8A%8Awordpress%E5%90%8E%E5%8F%B0%E7%9A%84%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9D%80%E4%BF%AE%E6%94%B9%E5%90%8E%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>我使用的方法是修改MySQL里面中的数据</p><p>首先登陆到自己的服务器后输入：</p><pre><code class="shell">    mysql -u root -p</code></pre><p>再输入密码，以使用root账户登录服务器，我之前设置过root为mysql管理账户，你应当输入你设置的账户。  </p><p>切换到你的wordpress的数据库，以我为例，我的wordpress数据库名字为wordpress<br>输入（注意分号）：</p><pre><code class="SQL">USE wordpress;    UPDATE wp_options SET option_value = replace(option_value, &#39;你输错的URL&#39;,&#39;正确的URL&#39;) WHERE option_name = &#39;home&#39; OR option_name = &#39;siteurl&#39;;</code></pre><p>然后再输入以下指令，把“输错的URL”和“正确的URL”按你自己的情况修改。</p><p>还有一种方法2，即进入你的phpmyadmin页面，如<a href="http://example.com/phpmyadmin/">http://example.com/phpmyadmin/</a> （example.com是你的地址）选择你的wordpress数据库，再选择wp_options一项，修改其中的home和siteurl两项为正确的地址，这个方法更简单，但是我之前没来得及用，之后实测此方法是有效的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世界，您好!</title>
      <link href="/2018/10/08/%E4%B8%96%E7%95%8C%EF%BC%8C%E6%82%A8%E5%A5%BD!/"/>
      <url>/2018/10/08/%E4%B8%96%E7%95%8C%EF%BC%8C%E6%82%A8%E5%A5%BD!/</url>
      
        <content type="html"><![CDATA[<p>Hello world！This is emon100.</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
